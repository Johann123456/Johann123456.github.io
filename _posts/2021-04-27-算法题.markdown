---
layout:     post
title:      "算法题整理"
subtitle:   "整理中…"
date:       "2021-04-27"
author:     "Johann"
# # header-img: "img/post-bg-js-version.jpg"
tags:
    - 算法
---
- [leetcode题目](#leetcode题目)
  - [168.excel表列名称](#168excel表列名称)
  - [718.最长重复子数组](#718最长重复子数组)
  - [300.最长递增子序列](#300最长递增子序列)
  - [31.下一个排列](#31下一个排列)
  - [33.搜索旋转排序数组](#33搜索旋转排序数组)
  - [20.有效括号](#20有效括号)
  - [236.二叉树最近公共祖先](#236二叉树最近公共祖先)
  - [二叉树锯齿形遍历](#二叉树锯齿形遍历)
  - [88.合并有序数组](#88合并有序数组)
  - [219.存在重复元素II](#219存在重复元素ii)
  - [415.字符串相加](#415字符串相加)
  - [121.买卖股票最佳时机](#121买卖股票最佳时机)
  - [142.环形链表II](#142环形链表ii)
  - [160.相交链表](#160相交链表)
  - [395.至少含有k个重复字符的最长子串](#395至少含有k个重复字符的最长子串)
  - [15.三数之和 611.有效三角形个数](#15三数之和-611有效三角形个数)
  - [146.LRU缓存机制](#146lru缓存机制)
  - [440.字典序第k小数字](#440字典序第k小数字)
  - [215.数组中第k个最大元素](#215数组中第k个最大元素)
  - [3.无重复最长字符串](#3无重复最长字符串)
  - [206.反转链表 25.K个一组反转链表](#206反转链表-25k个一组反转链表)
  - [1.两数之和](#1两数之和)
  - [53.最大子序和](#53最大子序和)
  - [21.合并有序链表](#21合并有序链表)
  - [46.全排列](#46全排列)
  - [47.全排列II](#47全排列ii)
  - [54.螺旋矩阵](#54螺旋矩阵)
  - [94.二叉树中序遍历、后序遍历](#94二叉树中序遍历后序遍历)
  - [232.栈实现队列](#232栈实现队列)
  - [200.岛屿数量](#200岛屿数量)
  - [5.最长回文子串](#5最长回文子串)
  - [22.链表倒数第k个节点](#22链表倒数第k个节点)
  - [300.最长上升子序列](#300最长上升子序列)
  - [2.两数之和](#2两数之和)
  - [42.接雨水](#42接雨水)
  - [101.对称二叉树](#101对称二叉树)
  - [143.重排链表](#143重排链表)
  - [112.路径总和](#112路径总和)
  - [113.路径和II](#113路径和ii)
  - [124.二叉树最大路径和](#124二叉树最大路径和)
  - [56.合并区间](#56合并区间)
  - [41.缺失的第一个正数](#41缺失的第一个正数)
  - [153.搜索旋转排序数组I/II](#153搜索旋转排序数组iii)
  - [322.零钱兑换](#322零钱兑换)
  - [165.比较版本号](#165比较版本号)
  - [105.前序中序恢复二叉树](#105前序中序恢复二叉树)
  - [链表快排](#链表快排)
  - [32.最长有效括号](#32最长有效括号)
### topk
最大的，用小根堆，大于堆顶就push，然后pop堆顶；最小的，用大根堆，小于堆顶就push，然后pop堆顶；
### 0-1背包
**二维dp数组**
每一件物品都有放和不放两种方案，dp[i][j]表示从0-i物品中任取，放到容量为j的背包，最大的价值
dp[i][j] = max(dp[i - 1][j - w[i]] + v[i], dp[i - 1][j])

**一维定义**，dp[j]容量为j的背包能放的最大价值,同样有不选和选第i个物品两种方案
dp[j] = max(dp[j], dp[j - w[i]] + v[i])

**遍历顺序**，一维的一定要倒序遍历容量，保证每个物品只被放入一次，其实由于每个物品i只用一次，所以如果是从前往后那value[i]在后面被累加了，而倒序遍历可以保证dp[j]是由dp[j - weight[i-1]] + value[i]来更新的，每次只用了一次value[i]，相当于滚动数组的上一行
```C++
for(int i = 0; i < weight.size(); ++i){//物品
    for(int j = bagweight; j >= weight[i]; --j){//背包容量
        dp[j] = max(dp[j], dp[j - weight[i]] + value[i]);
    }
}
```
求组合数，先遍历物品，求排列数，先遍历背包容量leetcode518、377

## leetcode题目
### 168.excel表列名称
26进制转换，但是没有0，1对应A，26对应Z，`res += (r-1)%26+'A'`先转成0-25然后再加'A'转成对应字符，如果余数r是0就强行让r变成26，然后把数-26。
```C++
while(col>0){
    int r = col%26;
    if(r==0){
        r = 26;
        col -= 26;
    }
    res += r + 'A';
    col /= 26;
}

```

### 718.最长重复子数组
两个数组重复的连续子数组最大长度，动态规划，`dp[i][j] = dp[i-1][j-1] + 1`优化成一维的，只需要保存当前位置左上角的元素upleft
```C++
for(int i = 0;i < m; ++i){
    upleft = 0;
    for(int j = 0;j < n; ++j){
        int tmp = dp[j];//暂存更新前的j元素就是下一行的upleft
        if(nums[i]==nums[j]){
            dp[j] = (j==0)? 1 : upleft + 1;//把j=0的情况考虑在这
            res = max(res, dp[j]);//结果必须在这更新
        }
        else{
            dp[j] = 0;
        }
        upleft = tmp;
    }
}
```

### 300.最长递增子序列
找到数组中最长严格递增**子序列**长度，动态规划，dp[i]表示以i为结尾的最长递增子序列长度
```C++
if(nums[i]>nums[j]){
    dp[i] = max(dp[j]+1, dp[i]);
}
```

### 31.下一个排列
下一个排列，数学，从低位开始，找到递增的结尾的位置i，以及这个左边第一个比它大的位置j，交换i,j元素，并把i后面的反向

### 33.搜索旋转排序数组
旋转之后必有一边是有序的，二分法，注意左右边界
```C++
if(nums[mid]==target) return mid;//这里判断了mid后面关于mid的区间都不加等号
if(nums[mid]<nums[right]){//右有序
    if(target>nums[mid]&&target<=nums[right]){//这里区间开闭是因为前面判断了
        left = mid + 1;
    }
}
```

### 20.有效括号
三种括号，为了查询方便可以用哈希表key是右扩号，val是对应左括号，然后左括号入栈，右扩号看栈顶是否匹配以及栈是否为空（栈为空右扩号多），最后再看栈是否为空

### 236.二叉树最近公共祖先
递归，左右子树找p,q找到就返回，然后看pq是否为空，都不为空则是根节点，一个为空则另一个是祖先
```C++
if(root==nullptr||root=p||root==q){
    return root;
}
TreeNode* left = lowest(root->left, p, q);
TreeNode* right = lowest(root->right, p, q);
if(!p&&!q) return root;
return left==nullptr?right:left;
```

### 二叉树锯齿形遍历
就是层序遍历，然后用一个双端队列暂存结果，标志位表示应该push_back()还是push_front()。
```C++
que.push(root);
bool order = true;
while(!que.empty()){
    int n = que.size();
    for(int i = 0; i < n;++i){
        TreeNode* node = que.top();que.pop();
        if(order){//正序
            deq.push_back(node->val);
        }
        else{
            deq.push_front(node->val);
        }
        if(node->left) que.push(node->left);
        if(node->right) que.push(node->right);
    }
    order = !order;
}
```

### 88.合并有序数组
与链表不同，不能连接，遍历两个数组的时候要在两个都为空的时候再停止循环

### 219.存在重复元素II
数组中是否有下标间隔不超过k的相同元素，k个元素的滑动窗口（hashset），如果大小超过k则把最左边的删掉

### 415.字符串相加
字符串形式的数相加求和\
模板
```C++
while(m>=0||n>=0||c!=0){//两个字符串和进位不为空
    int a = (m>=0)? num1[m]-'0':0;
    int b = (n>=0)? num2[n]-'0':0;
    int ans = a + b + c;
    res = ans%10+'0';
    c = ans/10;
    m--; n--;
}
```

### 121.买卖股票最佳时机
只进行一次交易，dp[i]表示第i天卖出的利润，dp[i]<0则dp[i]=0，新买一个股票
`dp[i] = dp[i-1]+nums[i]-nums[i-1];`

### 142.环形链表II
快慢指针，相遇之后，让一个指针从头开始走，慢指针从相遇点开始走，他们会相遇在环入口
```C++
while(fast!=nullptr&&fast->next!=nullptr){
    if(slow==fast){
        while(p!=slow){

        }
        return p;
    }
}
```

### 160.相交链表
两个指针，分别从头开始，如果到尾部再从另一个头开始。注意避免死循环。
```C++
while(p1!=p2){
    p1 = p1==nullptr?headB:p1->next;//这里要让p1有机会是nullptr，所以判断的是p1而不是p1->next
    p2 = p2==nullptr?headA:p2->next;
}
```

### 395.至少含有k个重复字符的最长子串
递归，先统计每个字符串的次数，按照不满足的位置进行切分，并更新结果，需要注意的是C++的split字符串要自己写
```C++
//按照某个字符分割字符串并删除这个字符
vector<string> split(string s, char flag = ' '){
    vector<string> res;
    string temp;
    istringstream iss(s);
    while(getline(iss,temp,flag)){
        res.push_back(temp);
    }
    return res;
}
int longestk(string s, int k){
    if(s.length() < k) return 0;
    unordered_map<char,int> table;
    for(auto c:s){
        table[c]++;
    }
    unordered_set<char> charset(s.begin(),s.end());
    for(auto c:charset){
        if(table[c]<k){
            vector<string> temp = split(s, c);
            for(auto str:temp){//递归
                res = max(longest(s,k), res);
            }
            return res;
        }
        return res;
    }
    return s.length();
}
```

### 15.三数之和 611.有效三角形个数
固定最大的，然后双指针，要求不重复所以要判断最大的是否重复以及右指针是否重复
```C++
for(int m = n-1;m>=2;--m){
    left = 0, right = m-1;
    if(nums[m]==nums[m-1]) continue;
    while(left<right){
        while(nums[right]==nums[right+1]) right--;
    }
}
```

### 146.LRU缓存机制
常数时间查找->哈希表，常数时间删除插入->链表，所以用链表维护值，用哈希表维护key和节点索引。

### 440.字典序第k小数字
给n和k，找1-n中字典序为k的。数学方法，其实也是个前缀树\
需要用一个函数求当前数字为前缀并且在n范围内的数字共有多少个，然后对前缀数字i进行遍历
```C++
int getcount(int i, int n){
    int cnt = 0, j = i + 1;
    while(i <= n){
        cnt += min(j,n)-i;
        i = i*10;
        j = j*10;
    }
    return cnt;
}
int findKnum(int n, int k){
    int p = 1, i = 1;
    while(p<k){
        cnt = getcount(i);
        if(p + cnt > n){
            i = i*10;
            p++;
        }
        else if(p+cnt<=n){
            i++;
            p += cnt;
        }
    }
}
```
### 215.数组中第k个最大元素
堆排序，快排，或者小顶堆\
快速选择：
```C++
int quickfind(vector<int>& nums, int left, int right, int index){
    int q = partion(nums,left,right);
    if(q==index) return nums[q];
    return index < q ? quickfind(nums,left,q-1,index):quick(nums,left,q-1,index);
}
res = quickfind(nums, 0, nums.size()-1, nums.size()-k);
```

### 3.无重复最长字符串
双指针，维护哈希表，如果出现重复的就删除左端直到删除了哈希表里面的重复字符，否则插入
```C++
int right = 0;
for(int left = 0;left<n;++i){
    while(right<n && !charset.count(s[right])){
        charset.insert(s[right]);
        right++;
    }
    charset.erase(s[left]);
    res = max(res, right-left);
}
```

### 206.反转链表 25.K个一组反转链表
反转一个链表
```C++
while(cur){
    nxt = cur->next;
    cur->next = pre;//这里之前pre初始化为nullptr
    pre = cur;
    cur = nxt;
}
```
k个一组反转，需要一个辅助的反转head和tail之间链表的函数
```C++
reverse(ListNode* head, ListNode* tail){
    //这样执行完第一个节点翻转之后直接连在了链表尾，少做了一个拼接
    pre = tail->next, cur = head, nxt = nullptr;
    while(pre!=tail)//这里条件是pre!=tail，否则cur没到tail就结束了
}
//在head前建一个dummy节点，否则反转之后原来头结点不是现在头结点
//tail是pre然后移动k步才是这段的tail
reverseK(ListNode* head, int k){
    pre = dummy,cur = head;
    while(cur){
        //更新tail
        ListNode* tail = pre;
        for(int i = 0;i < k; ++i){
            tail = tail -> next;
            if(tail==nullptr){//如果提前到了空节点证明不足k个
                return dummy->next;
            }
        }
        pre->next = reverse(cur,tail).first;//连接左端
        pre = reverse(cur,tail).second;//更新pre
        cur = pre->next;//更新cur
    }
}
```

### 1.两数之和
先查找target-num[i],不存在则插入哈希表{num[i], i},减少一层循环

### 53.最大子序和
连续子数组最大和，dp[i]表示以i为结尾的最大子序和
`dp[i] = max(dp[i-1]+nums[i], nums[i])`是选择累加还是重新开始。

### 21.合并有序链表
链表容易拼接，所以可以&&
```C++
ListNode* dummy = new ListNode(0);
while(p1!=nullptr&&p2!=nullptr){
    if(p1->val<=p2->val){
    }
    else{
    }
    p = p->next;
}
p->next = (p1==nullptr)? p2 : p1;
```

### 46.全排列
无重复数字全排列，回溯
```C++
vector<vector<int>> permute(vector<int>& nums){
    backtrack(res, nums, 0);
}
void backtrack(res, vector<int> nums, int index){
    if(index==nums.size()){
        res.push_back(nums);
        return ;
    }
    for(int i = index;i < nums.size();++i){
        swap(nums[index], nums[i])//往index位置填充
        backtrack(res, nums, index+1);//填充下一个位置
        swap(nums[index], nums[i]);//换回来
    }
}
```

### 47.全排列II
有重复元素全排列


### 54.螺旋矩阵
顺时针螺旋打印矩阵，四个边界，需要判断是哪个边界到了
```C++
while(left<=right&&up<=down){
    for(int i = left;i<=right;++i)//left->right
    for(int i = top+1;i<=down;++i)//up->down
    if(top!=down){//横着的长方形没有从右到左
        for(int i = right-1;i>=left;--i)//right->left
    }
    if(left!=right){//竖着的长方形没有从下到上
        for(int i = down-1;i>=up+1;--i)//down->up
    }
    left++;right--;up++;down--;
}
```

### 94.二叉树中序遍历、后序遍历
```C++
//中序
TreeNode* cur = root;
while(cur!=nullptr||!stk.empty()){
    while(cur!=nullptr){
        stk.push(cur);
        cur = cur->left;
    }
    cur = stk.top();stk.pop();
    res.push_back(cur->val);
    cur = cur->right;
}
//后续遍历
TreeNode* cur = root;
while(!stk.empty()||cur!=nullptr){
    while(cur!=nullptr){
        stk.push(cur);
        cur = cur->left;
    }
    cur = stk.top();stk.pop();
    if(cur->right==nullptr||cur->right==pre){//右节点是空或者是访问过的
        res.push_back(cur->val);
        pre = cur;
        cur = nullptr;
    }
    else{//有右节点
        stk.push(cur);
        cur = cur->right;
    }
}
//前序
stk.push(root);
while(!stk.empty()){
    TreeNode* node = stk.top();stk.pop();
    res.push_back(node->val);
    if(node->left) stk.push(node->left);
    if(node->right) stk.push(node->right);
}
```
### 232.栈实现队列
两个栈，一个输入，一个输出，当输出栈为空的时候把输入栈的都放到输出栈里

### 200.岛屿数量
深度优先遍历，遍历矩阵中每个元素，如果是‘1’并且没访问过则dfs把所有相邻的标记为访问过。执行dfs次数就是岛屿个数
```C++
void dfs(i,j,grid,vis){
    for(k<4){
        int dx = i + opt[k][0];
        int dy = j + opt[k][1];
        if(check(dx,dy)&&vis==false&&grid[dx][dy]=='1'){
            dfs(dx,dy,grid,vis);
        }
    }
}
for()for(){
    if(){
        dfs(i,j,grid,vis);
    }
}
```

### 5.最长回文子串


### 22.链表倒数第k个节点
fast先走k步，然后跟slow一起走，快指针到结尾慢指针返回

### 300.最长上升子序列
`dp[i] = max(dp[j]+1, dp[i])`

### 2.两数之和
两个链表求和.
```C++
//定义结果的头尾节点
ListNode* head = nullptr, *tail = nullptr
while(p1||p2){
    int a = p1!=nullptr? p1->val : 0;
    int b = p2!=nullptr? p2->val : 0;
    int sum = a + b + carry;
    if(head==nullptr){//头节点为空则新建节点
        head = tail = new ListNode(sum%10);
    }
    else{//在尾部插入
        tail->next = new ListNode(sum%10);
        tail = tail->next;
    }
    carry = sum / 10;
    if(p1!=nullptr) p1 = p1->next;
    if(p2!=nullptr) p2 = p2->next;
}
//最后要判断进位
if(carry > 0) tail->next = new ListNode(carry);
```

### 42.接雨水
单调栈，横向计算，一个位置横向能盛水的容量取决于左右和当前位置高度差的最小值，所以维护一个递减栈，碰到递增点就把它当做right，然后边pop栈边更新栈顶横向能盛水的结果，**如果没有递增点就可以不用更新结果。**所以也不用插入额外的元素
```C++
for(int i = 0;i < n; ++i){
    while(!stk.empty()&&height[stk.top()]<height[i]){
        int cur = stk.top();stk.pop();
        if(stk.empty()) break;//左边没有cur大的直接结束
        left = stk.top();
        right = i;
        ans += (min(height[left],height[right])-height[cur])*(right-left-1);
    }
}
```

### 101.对称二叉树
判断是否是镜像对称，递归，
```C++
bool check(TreeNode *p1, TreeNode *p2){
    if(p1==nullptr&&p2==nullptr){
        return true;
    }
    else if(p1==nullptr||p2==nullptr){
        return false
    }
    else if(p1->val!=p2->val){
        return false;
    }
    else{
        return check(p1->left, p2->right)&&check(p1->right, p2->left);
    }    
}
//迭代方法，层序遍历，两个指针u,v
while(!que.empty()){
    u = que.front();que.pop();
    v = que.front();que.pop();
    else if(u->val == v->val){
        que.push(u->left);que.push(v->right);
        que.push(u->right);que.push(v->left);
    }
}
```

### 143.重排链表
拼接，第一个后面跟最后一个，第二个后面跟倒数第二个，找中点，反转后半部分，拼接，注意为了拼接方便需要让前半部分长一点
```C++
slow = head, fast = head;//slow是中点前一个节点，后半部分从slow->next开始
while(fast->next!=nullptr&&fast->next->next!=nullptr){}
```

### 112.路径总和
从根节点到叶子节点是否存在路径和为target，递归
```C++
bool find(TreeNode *root, int target){
    if(root==nullptr){
        return false;
    }
    if(root->val==target&&root->left==nullptr&&root->right==nullptr){//必须要到根节点
        return true;
    }
    return find(root->left, target-root->val)||find(root->right, target-root->val);
    
}
```

### 113.路径和II
找到和为target的根节点到叶子节点的路径，回溯
```C++
void backtrack(root,target,res,path){
    if(!root) return ;
    path.push_back(root->val);
    if(target==root->val&&!root->left&&!root->right){
        res.push_back(path);
    }
    backtrack(root->left,target-root->val,res,path);//查找root左边子树是否可以满足要求
    backtrack(root->right,target-root->val,res,path);//查找右边子树能否满足要求
    path.pop_back();//都不满足要求把这个节点从路径中pop
}
```

### 124.二叉树最大路径和
任意路径，可以不从根节点开始的所有路径和的最大值。递归，每个节点计算左右子树对该节点的贡献，如果到了叶子结点就返回0，如果贡献小于0，就让贡献为0，如同砍掉。还要分两种情况讨论：1、根节点向上连接，这时候左右子树只选一个。2、根节点不向上连接，左右子树都要选。
```C++
sum = INT_MIN//sum要初始化为负的最大，否则如果全是负数会返回0
int maxpathsum(TreeNode *root, int &sum){
    if(root==nullptr) return 0;
    int left = maxpathsum(root->left, sum);//计算左边贡献并更新sum
    int right = maxpathsum(root->right, sum);
    sum = max(sum, root->val+left+right);//root不向上连接情况下的最大值
    int outmax = root->val + max(left, right);//root向上连接情况下的贡献
    return max(outmax, 0);//对外贡献小于0则直接砍掉
}
```

### 56.合并区间
区间重合直接合并，返回合并后的区间。按照左边界排序，边遍历边更新左右边界。
```C++
for(auto e:intervals){
    if(e[0]<=right){
        right = max(e[1], right);
    }
    else{//不相交
        res.push_back({left,right});//如果不相交，先把上次的范围放到结果中
        left = e[0];
        right = e[1];
    }
}
res.push_back({left,right});//最后一个放进来
```

### 41.缺失的第一个正数
未排序数组，找出没出现的第一个正整数，时间O(n)，空间O(1)
```C++
//把数字当做下标放到对应位置，
for(int i = 0; i < n; ++i){
    while(nums[i]>0&&nums[i]<=n&&nums[nums[i]-1]!=nums[i]){//若有相同的数，则证明针对这个位置的交换已经完成
        swap(nums[nums[i]-1], nums[i]);
    }
}
for(int i = 0; i < n; ++i){
    if(nums[i]!=i+1){
        return i+1;
    }
}
return n+1;//如果没有碰到不满足要求的，则说明数组里面的是从1-n的数
```

### 153.搜索旋转排序数组I/II
二分，没有相同元素则min到right之间一定是递增的，left到min左边一个也是递增的，并且`nums[right]<nums[left]`，所以可以用mid与right的大小关系判断min与mid关系
```C++
while(left<right){
    if(nums[mid]<nums[right]){//mid在min右边
        right = mid;
    }
    else if(nums[mid]>nums[right]){//mid在min左边
        left = mid + 1;
    }
    else{//nums[mid]==nums[right]
        right--;//有重复的则左移右端点
    }
}
```

### 322.零钱兑换
背包问题，dp[j] = min(dp[j], dp[j-coins[i]]+1)
```C++
//最少的硬币个数
for(i = 0;i < n; ++i){//物品
    for(j = coins[i];j<amount;++j){//容量,可以用多次所以是++j
        dp[j] = min(dp[j], dp[j-coins[i]]+1);//更新最小个数
    }
}
//凑数数额的方法数
dp[j] += dp[j-coins[i]];
```

### 165.比较版本号
分割字符串存到数组，然后比较
```C++
//分割字符串
vector<int> split(string s, char flag = '.'){
    vector<int> res;
    istringstream iss(s);
    string temp = "";
    while(getline(iss,temp,flag)){
        int num = 0;
        for(auto e:temp){
            num = 10*num + e - '0';
        }
        res.push_back(num);
    }
    return res;
}
//比较的时候不够的认为是0
for(i = 0; i < max(m,n); ++i){
    int num1 = i < m? a[i] : 0;
    int num2 = i < n? b[i] : 0
}
```

### 105.前序中序恢复二叉树
递归，前序的第一个节点是根节点，每次递归需要确定前序和中序遍历中的左右子树的整体位置
```C++
build tree(preorder,inorder,0,n-1,0,n-1);
TreeNode* buildtree(vector<int>& preorder, vector<int>& inorder, int preleft, int preright, int inleft, int inright){
    if(preleft > preright){//前序中左右相等是叶子节点，左>右则是空节点
        return nullptr;
    }
    int rootindex = hashtable[preorder[preleft]];//中序遍历数组中root的下标
    int lenleft = rootindex-preleft;//左子树长度
    root = new TreeNode(inorder[rootindex]);
    //左子树[preleft,preright]
    root->left = buildtree(preorder,inorder,preleft+1,preleft+lenleft,inleft,rootindex-1);
    //右子树
    root->right = buildtree(preorder,inorder,preleft+1+lenleft,preright,rootindex+1,inright); 
}
```

### 链表快排
关键是如何划分
```C++
ListNode *sortlist(ListNode* head, nullptr){
    if(head==nullptr||head->next==nullptr) return head;
    ListNode* dummy = new ListNode(-1);
    dummy->next = head;
    quicksort(dummy,nullptr);
}
ListNode *quicksort(ListNode *head, ListNode *tail){
    if(head==tail||head->next==tail||head->next->next==tail) return head;
    ListNode *dummy = new ListNode(-1);
    ListNode *partition = head->next, *p = head, *tp = dummy;
    //对head和tail之间的链表按照partition进行划分
    while(p->next!=tail){
        if(p->next->val < partition->val){
            tp->next = p->next;//连接到一个新的链表上
            tp = tp->next;
            p->next = p->next->next;//很关键！删除原链表里面的值，相当于把小的值的节点直接删掉了，连接到后面的节点上了
        }
        else{
            p = p->next;//往下挪动一个节点
        }
    }
    //将较小的值的链表插入到原链表中
    tp->next = head->next;//右端
    head->next = dummy->next;//左端
    quicksort(head,partition);
    quicksort(partition,tail);
    return head->next;
}
```

### 32.最长有效括号
找到由（）组成的字符串里面的最长有效的括号长度。栈里面存放连续的合法括号的下标，栈底存放的是第一个不匹配的右扩号的下标
```C++
stk.push(-1);//后面会先pop再判断，放一个dummy元素方便操作
for(int i = 0;i < n; ++i){
    if(s[i]=='('){
        stk.push(i);
    }
    else{
        stk.pop();//匹配
        if(stk.empty()){//动了栈底元素，证明不匹配了
            stk.push(i);//更新栈底
        }
        else{
            ans = max(ans, i-stk.top());//更新结果
        }
    }
}
```