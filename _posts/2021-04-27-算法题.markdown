---
layout:     post
title:      "算法题整理"
subtitle:   "整理中…"
date:       "2021-04-27"
author:     "Johann"
# # header-img: "img/post-bg-js-version.jpg"
tags:
    - 算法
---
### topk
最大的，用小根堆，大于堆顶就push，然后pop堆顶；最小的，用大根堆，小于堆顶就push，然后pop堆顶；
# 动态规划
## 背包问题
### 0-1背包
**二维dp数组**
每一件物品都有放和不放两种方案，dp[i][j]表示从0-i物品中任取，放到容量为j的背包，最大的价值
dp[i][j] = max(dp[i - 1][j - w[i]] + v[i], dp[i - 1][j])

**一维定义**，dp[j]容量为j的背包能放的最大价值,同样有不选和选第i个物品两种方案
dp[j] = max(dp[j], dp[j - w[i]] + v[i])

**遍历顺序**，一维的一定要倒序遍历容量，保证每个物品只被放入一次，其实由于每个物品i只用一次，所以如果是从前往后那value[i]在后面被累加了，而倒序遍历可以保证dp[j]是由dp[j - weight[i-1]] + value[i]来更新的，每次只用了一次value[i]，相当于滚动数组的上一行
```C++
for(int i = 0; i < weight.size(); ++i){//物品
    for(int j = bagweight; j >= weight[i]; --j){//背包容量
        dp[j] = max(dp[j], dp[j - weight[i]] + value[i]);
    }
}
```
求组合数，先遍历物品，求排列数，先遍历背包容量leetcode518、377
## 
# 双指针
## leetcode 76最小覆盖子串
# 回溯
# 图问题
# 并查集
# 贪心
# 二叉树的遍历
## 前序遍历
## 后序遍历
## 中序遍历