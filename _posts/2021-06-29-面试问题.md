---
layout:     post
title:      "面试问题整理"
subtitle:   "整理中…"
date:       "2021-06-29"
author:     "Johann"
# # header-img: "img/post-bg-js-version.jpg"
tags:
    - 面试题
---
topK:最大的，用小根堆，大于堆顶就push，然后pop堆顶；最小的，用大根堆，小于堆顶就push，然后pop堆顶；
## 1、C++基础
### static关键字
无论是全局静态变量还是局部静态变量，只要是**初始化**了的就在.data区，**未初始化**的就在.bss区。使用static的场景:
- （1）全局静态变量：全局变量前加static,作用域为其**所在的文件**，即它**对其他文件是不可见**的。
- （2）局部静态变量：在函数体中声明的静态变量，虽然**不会**随函数的结束而销毁，但是**作用域和函数体重其他变量是一样的**，在函数外不可见。下一次调用同样的函数时，其值会和上次保持一样。
- （3）静态函数：在函数名前面加上一个static即为静态函数，作用域为其所在的文件。
- （4）类中的静态**成员**：类中的静态成员需要在**类外初始化**，它不属于类的对象，而是属于类，所以使用它不需要this指针。
- （5）类中的静态成员函数：类中的静态函数也是属于整个类的，调用它也**不需要this指针**，所以函数体中也不能使用类的非静态成员（因为这个时候还没有对象，或者没有this指针不知道是哪个对象？）
### const在内存的哪里
被const修饰的是常量，不可修改，其约束的是编译器的行为，所以它在内存中的布局和普通变量一样在普通的变量区。
### int *const和const int *
**const在前**修饰的是解引用之后的内容，即**指针指向的对象**是const的；\
**const在后**修饰的是指针本身，即**指针地址**不可修改
### 成员函数后面加const
成员函数后面加const是**防止成员函数体内对成员对象进行修改**。与没有加const的函数属于**重载**，目的是让const对象调用const方法，非const对象调用非const方法。
### extern关键字
extern关键字表示其**修饰的变量或函数的定义在其源文件中**。
extern "C"表示接下来的内容按C语言的规则进行编译。比如C++编译器通过修改所有函数的名字来实现重载机制，C则是通过函数原本的名字来进行编译的。

### restrict
restrict,是C语言中的一种类型限定符（tpye qualifiers），用于告诉编译器，**对象已经被指针引用**，**不能**通过除该指针外所有其他之间或间接的方式来**修改该对象的内容**。

### 四种类型转换
- （1）reinterpret_cast：与C中的强制转换一样，没有任何限制
- （2）static_cast：用于各种隐式转换，用于void*与其他类型的指针之间的相互转换，**可用于多态父子类之间的转换但结果未知**
- （3）dynamic_cast：用于**父类指针**和**子类指针**，**父类引用和子类引用之间的转换**，若目标指针并非父类的子类，则会返回空，通过运行时类型推断实现的。
- （4）const_cast：用于将const类型转为非const类型。

### 隐式类型转换
没有显示类型转换的都是隐式转换，如①内置类型低精度的变量赋值给高精度的变量会发生隐式类型转换，②传给一个类的构造函数的变量若不是该类构造函数规定的参数类型的话也可能发生隐式类型转换。

### new/delete和malloc/free区别
- （1）new/delete是C++**关键字**，需要C++编译器支持。malloc/free是C**标准库函数**，需要包含相应头文件。
- （2）new分为两步，第一部分配内存，第二步调用构造函数；delete第一步调用析构函数，第二步释放内存。分配和释放内存底层使用malloc和free。
- （3）new返回的是**对象的指针**。malloc返回的是**void型指针**。
- （4）new失败后会抛出bad_alloc异常，并且可以使用set_new_handler设置new失败时的回调函数。malloc失败就返回空指针。

### C++类中可以定义应用数据成员吗？
可以，但必须使用初始化列表初始化

### 为什么用成员初始化列表会快一些
对于内置函数而言没有区别；对于用户定义的类而言，因为进入构造函数体后，所有对象都需要已经构造好，所以在之前会调用一次默认构造函数，然后在构造函数体内再调用一次特定的构造函数，这就会造成多调用了一次构造函数，损失效率。

### 多态和虚函数
多态就是同一个操作作用于不同的对象可以产生不同的效果，在C++中使用虚函数来实现多态。虚函数调用是一种只知道部分信息完成工作的机制，用户只需要知道接口而不需要知道具体对象，具体实现是依赖虚函数表，**有虚函数的类**中会有一个**指向虚函数表的指针**，当一个**派生类**自己实现了父类的虚函数后，会将该函数在**继承到的虚函数表**中的**地址改**写为其**重写**的虚函数的地址。

### C实现多态
仿照linux中虚拟文件系统的做法，结构体中有一个op对象，里面都是各种函数指针，不同的文件系统实现不同的函数，然后赋值给该函数指针。

### 析构函数为何必须是虚函数？C++默认的为何不是虚函数？
delete父类指针时必须要调用子类的析构函数。\
若默认析构函数是虚函数则每个类都需要引入虚函数表，没有必要。

### 重载、重写、隐藏
- 重载：函数名和返回值相同，参数列表不同
- 重写：不同层级的类中实现不同的虚函数
- 隐藏：不同层级的类中实现的同名函数

### 析构函数
一个对象生命周期结束的时候会调用它的析构函数，析构函数调用顺序：派生类析构函数->成员对象的析构函数->父类析构函数

### 析构函数可以是纯虚函数吗
可以。

### 在main()函数之前执行的函数
静态成员的构造函数

### C语言函数调用流程
将函数参数压栈\
将函数返回值压栈\
将栈帧指针（ebp寄存器值）压栈\
移动栈顶和栈帧指针，为函数创建一个新的栈帧。

### C参数的压栈顺序
从右往左，对于可边长参数，从左往右编译器难以确定明确的参数地址，而从右往左，最左的参数地址就是栈帧指针加上一个返回值的长度。

### 拷贝构造函数
用一个类对象初始化另一个类对象时；\
函数参数值传递时;\
返回值类型为对象时。

### C++中拷贝构造函数的形参能否进行值传递
不能，因为使用形参会调用拷贝构造函数，造成循环调用。

### do while(0)的目的
让代码不受分号，大括号的影响

## STL

### STL组成部分
容器、迭代器、分配器、算法、仿函数、配接器

### vector和list区别
都是线性容器，vector是顺序表支持随机访问，插入时间复杂度为O(n)，list是链表，只支持顺序访问，插入删除时间复杂度为O(1)。vector插入元素超过预留内存会向后继续扩张，并且每次扩张都是新建一个更大的vector然后把原来的复制过去，list不会。迭代器失效？

### map和set区别
map是键值对容器，map的迭代器key不可修改，value可修改；\
set是数据集合，迭代器不可修改。

### map的key如果是结构体需要重载<运算符

### 上千万数据的map如何释放内存
因为小于128byte的内存数据是用二级配置器申请的，使用完后会放回内存池，并没有真正释放，所以需要和临时空map对象swap后销毁临时swap对象。

### STL的allocator
是STL中广泛使用的对象配置器，提高了对象创建和销毁的效率。\
STL为了分工精细，使用配置器分配内存，使用construct和destroy函数处理对象的构造和析构。配置器分为两层，当所需内存大于128byte时嗲用二级配置器，其使用了内存池技术，以8byte为单位分了16种大小的槽位，每个槽位管理一个空闲链表，当空闲链表中没有空闲内存块时则从内存池中取一定数量的内存块放到空闲链表中。这里的空闲链表并没有多占用一点内存，其将next指针和内存块的头数据放在一个union中，避免了内存浪费。

### STL迭代器删除元素
STL使用erase删除迭代器内容。对于序列容器，erase返回所删除的迭代器的下一迭代器，但删除迭代器元素会导致后面迭代器均失效。对于关联容器，erase会导致被删除的迭代器失效，但是其它迭代器内容不失效，对于list来说，erase会返回下一迭代器，且其它迭代器均不失效。

### 迭代器的作用
迭代器的主要作用是将容器和算法分离，迭代器让容器的数据访问和遍历操作一致，这样算法使用迭代器对数据进行操作和遍历就不需要关心具体的容器类型，适用性更强。

### resize和reserve
resize改变的是size值，变小则后面的元素丢掉，变大则后面元素默认初始化。\
reserve改变的是容量，不增加元素。

### 编译

###C++源文件到可执行文件的过程
C++源文件->(预处理)->宏展开后的源文件->(编译阶段)->汇编文件->(汇编阶段)->可重定位的二进制文件->(链接阶段)->可执行文件


### 1、define与const区别
- #define是宏定义，在预处理阶段会直接进行替换，全局有效，不做类型检查，没有作用域限制，可能会污染全局变量
- const是编译器处理的，有类型检查，有作用域限制，不会污染全局变量。但是由于宏替换的方式，使得编译过程变慢（预编译+编译），但程序运行变快，因为早就已经替换好了，直接运行就可以了，而const编译时间少，但是运行速度慢，因为要找内存空间去开辟变量。
### 2、堆栈区别
- 栈：存放的是函数的参数、局部变量、返回值地址。每次调用函数都会使用一个新的栈，存放函数的调用信息和返回类型，和临时变量。栈空间从高位向低位地址增长，一块连续的内存，最大容量是预定的。
- 堆：动态分配内存，由程序员申请分配和释放
### 3、struct和class区别
- 默认继承访问权限。class默认是private，struct默认是public
- 默认访问权限。class作为**对象**的实现体，默认的成员变量访问控制是private。struct作为**数据结构**的实现体，默认的数据访问控制是public的。