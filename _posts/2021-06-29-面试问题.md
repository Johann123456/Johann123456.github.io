---
layout:     post
title:      "面试问题整理"
subtitle:   "整理中…"
date:       "2021-06-29"
author:     "Johann"
# # header-img: "img/post-bg-js-version.jpg"
tags:
    - 面试题
---
- [1、C++基础](#1c基础)
  - [程序内存布局](#程序内存布局)
  - [为什么要内存对齐](#为什么要内存对齐)
  - [对齐的规则](#对齐的规则)
  - [如何让类只在堆/栈上创建对象](#如何让类只在堆栈上创建对象)
  - [C++类的内存布局](#c类的内存布局)
  - [指针和引用的区别](#指针和引用的区别)
  - [智能指针](#智能指针)
  - [变量的声明和定义有什么区别？](#变量的声明和定义有什么区别)
  - [编译流程](#编译流程)
  - [智能指针](#智能指针-1)
  - [static关键字](#static关键字)
  - [const在内存的哪里](#const在内存的哪里)
  - [int *const和const int *](#int-const和const-int-)
  - [成员函数后面加const](#成员函数后面加const)
  - [extern关键字](#extern关键字)
  - [restrict](#restrict)
  - [四种类型转换](#四种类型转换)
  - [dynamic_cast](#dynamic_cast)
  - [static_cast](#static_cast)
  - [reinterpret_cast](#reinterpret_cast)
  - [const_cast](#const_cast)
  - [隐式类型转换](#隐式类型转换)
  - [new/delete和malloc/free区别](#newdelete和mallocfree区别)
  - [C++类中可以定义应用数据成员吗？](#c类中可以定义应用数据成员吗)
  - [为什么用成员初始化列表会快一些](#为什么用成员初始化列表会快一些)
  - [菱形继承和虚继承](#菱形继承和虚继承)
  - [多态和虚函数](#多态和虚函数)
  - [虚函数和纯虚函数](#虚函数和纯虚函数)
  - [构造函数是否可以是虚函数？](#构造函数是否可以是虚函数)
  - [内联函数可以是虚函数吗？](#内联函数可以是虚函数吗)
  - [静态成员函数可以是虚函数吗？](#静态成员函数可以是虚函数吗)
  - [隐藏](#隐藏)
  - [静态链接和动态链接的区别](#静态链接和动态链接的区别)
  - [内联函数与宏的区别](#内联函数与宏的区别)
  - [C实现多态](#c实现多态)
  - [析构函数为何必须是虚函数？C++默认的为何不是虚函数？](#析构函数为何必须是虚函数c默认的为何不是虚函数)
  - [静态多态和动态多态](#静态多态和动态多态)
  - [重载、重写、隐藏](#重载重写隐藏)
  - [析构函数](#析构函数)
  - [析构函数可以是纯虚函数吗](#析构函数可以是纯虚函数吗)
  - [在main()函数之前执行的函数](#在main函数之前执行的函数)
  - [C语言函数调用流程](#c语言函数调用流程)
  - [C参数的压栈顺序](#c参数的压栈顺序)
  - [拷贝构造函数](#拷贝构造函数)
  - [C++中拷贝构造函数的形参能否进行值传递](#c中拷贝构造函数的形参能否进行值传递)
  - [do while(0)的目的](#do-while0的目的)
- [STL](#stl)
  - [STL组成部分](#stl组成部分)
  - [STL内存池](#stl内存池)
  - [vector和list区别](#vector和list区别)
  - [map和set区别](#map和set区别)
  - [map的key如果是结构体需要重载<运算符](#map的key如果是结构体需要重载运算符)
  - [上千万数据的map如何释放内存](#上千万数据的map如何释放内存)
  - [STL的allocator](#stl的allocator)
  - [STL迭代器删除元素](#stl迭代器删除元素)
  - [迭代器的作用](#迭代器的作用)
  - [迭代器失效](#迭代器失效)
  - [resize和reserve](#resize和reserve)
  - [编译](#编译)
  - [define与const区别](#define与const区别)
  - [堆栈区别](#堆栈区别)
  - [struct和class区别](#struct和class区别)
- [网络编程](#网络编程)
  - [判断是长链接还是短连接](#判断是长链接还是短连接)
  - [浏览器断点续传](#浏览器断点续传)
  - [Reactor模型](#reactor模型)
  - [TCP的connect函数](#tcp的connect函数)
  - [read和write](#read和write)
    - [read](#read)
    - [write](#write)
  - [HTTPS如何握手的](#https如何握手的)
  - [https可以被抓包吗？](#https可以被抓包吗)
  - [get和post区别](#get和post区别)
  - [TCP与UDP的区别](#tcp与udp的区别)
  - [TCP、UDP首部格式](#tcpudp首部格式)
  - [TCP如何保证可靠性](#tcp如何保证可靠性)
  - [TCP的粘包](#tcp的粘包)
  - [TCP滑动窗口](#tcp滑动窗口)
  - [拥塞控制](#拥塞控制)
  - [浏览器输入url之后发生了什么？](#浏览器输入url之后发生了什么)
  - [拥塞发生时拥塞控制的行为](#拥塞发生时拥塞控制的行为)
    - [如何判断拥塞发生？](#如何判断拥塞发生)
  - [为啥不能是两次握手？](#为啥不能是两次握手)
  - [为啥不用四次？](#为啥不用四次)
  - [TCP三次握手初始序列号为什么不用固定值？](#tcp三次握手初始序列号为什么不用固定值)
  - [TCP的保活](#tcp的保活)
  - [TIME_WAIT作用](#time_wait作用)
  - [为啥是2MSL](#为啥是2msl)
  - [出现大量CLOSE_WAIT原因以及处理方法](#出现大量close_wait原因以及处理方法)
  - [SYN洪范攻击](#syn洪范攻击)
  - [IP和MAC地址作用](#ip和mac地址作用)
  - [http长连接和短连接？](#http长连接和短连接)
  - [http是不保存状态的协议，如何知道用户状态？](#http是不保存状态的协议如何知道用户状态)
    - [Cookie 被禁⽤怎么办?](#cookie-被禁怎么办)
  - [cookie和session的区别](#cookie和session的区别)
  - [IP层如何知道报文该给哪个应用程序，如何区分TCP还是UDP报文](#ip层如何知道报文该给哪个应用程序如何区分tcp还是udp报文)
  - [IP数据包的内容](#ip数据包的内容)
  - [DNS解析流程](#dns解析流程)
  - [https与http区别？](#https与http区别)
  - [https与http](#https与http)
  - [http与TCP](#http与tcp)
  - [http1.0、http1.1、](#http10http11)
  - [http状态码和方法](#http状态码和方法)
- [操作系统](#操作系统)
  - [什么是操作系统？](#什么是操作系统)
  - [系统调用](#系统调用)
  - [进程有几种状态](#进程有几种状态)
  - [进程间通信](#进程间通信)
  - [kill-9之后发生了什么？](#kill-9之后发生了什么)
  - [线程间同步方式？](#线程间同步方式)
  - [操作系统中的进程调度算法？](#操作系统中的进程调度算法)
  - [用户态和内核态](#用户态和内核态)
  - [用户态和内核态的切换](#用户态和内核态的切换)
  - [中断分类](#中断分类)
  - [并行和并发](#并行和并发)
  - [为什么要并发？](#为什么要并发)
  - [进程和线程的区别](#进程和线程的区别)
  - [进程和线程的选取](#进程和线程的选取)
  - [线程崩溃不一定会导致进程崩溃](#线程崩溃不一定会导致进程崩溃)
  - [线程间的共享和私有数据](#线程间的共享和私有数据)
    - [共享数据：](#共享数据)
    - [私有数据：](#私有数据)
  - [如何检查内存泄漏](#如何检查内存泄漏)
  - [malloc大内存跟物理内存的关系](#malloc大内存跟物理内存的关系)
  - [死锁成立的条件](#死锁成立的条件)
  - [死锁检测和恢复](#死锁检测和恢复)
  - [死锁预防](#死锁预防)
  - [死锁避免](#死锁避免)
    - [资源拒绝分配（银行家算法）](#资源拒绝分配银行家算法)
    - [死锁避免优缺点](#死锁避免优缺点)
  - [互斥锁、递归锁、读写锁、自旋锁、RCU](#互斥锁递归锁读写锁自旋锁rcu)
  - [内存模型](#内存模型)
  - [操作系统中的内存管理机制？](#操作系统中的内存管理机制)
  - [页表管理机制中有两个很重要的概念：快表和多级页表](#页表管理机制中有两个很重要的概念快表和多级页表)
    - [快表（TLB Translation Lookaside Buffer）](#快表tlb-translation-lookaside-buffer)
    - [多级页表](#多级页表)
  - [分页和分段的共同点和区别](#分页和分段的共同点和区别)
  - [CPU如何寻址？为什么需要虚拟地址空间？](#cpu如何寻址为什么需要虚拟地址空间)
    - [为什么需要虚拟地址空间？](#为什么需要虚拟地址空间)
  - [什么是虚拟内存？](#什么是虚拟内存)
  - [什么是局部性原理？](#什么是局部性原理)
  - [什么是虚拟存储器？](#什么是虚拟存储器)
  - [虚拟内存技术如何实现的？](#虚拟内存技术如何实现的)
    - [请求分⻚与分⻚存储管理，两者有何不同呢？](#请求分与分存储管理两者有何不同呢)
  - [常见的页面置换算法？](#常见的页面置换算法)
  - [线程切换时都有哪些内容？](#线程切换时都有哪些内容)
  - [OS如何做到原子操作](#os如何做到原子操作)
  - [线程上下文切换时，寄存器是否会保存全局变量](#线程上下文切换时寄存器是否会保存全局变量)
  - [寄存器SP的作用](#寄存器sp的作用)
  - [MMU和TLB](#mmu和tlb)
  - [五种IO模型](#五种io模型)
- [数据结构](#数据结构)
  - [哈希表、哈希冲突如何解决？](#哈希表哈希冲突如何解决)
  - [红黑树](#红黑树)
- [题](#题)
  - [两个线程循环打印1-100](#两个线程循环打印1-100)
  - [实现智能指针](#实现智能指针)
  - [手写单例模式](#手写单例模式)
    - [Meyer's Singleton](#meyers-singleton)
    - [饿汉模式](#饿汉模式)
    - [懒汉模式](#懒汉模式)


## 1、C++基础
### 程序内存布局
- 栈区：由编译器自动分配释放，存储函数的参数值，局部变量等
  - const局部变量存储在栈区，栈区向地址减小的方向增长。
- 堆区：由程序员申请和释放，分配方式类似于链表
  - 增长方向与内存地址增长方向相同，是不连续的区域，使用链表存储空闲节点
- 全局/静态区：全局变量和静态变量存储在一起的，在程序编译时分配
- 文字常量区：存储常量字符串
- 程序代码区：存储函数体（类的成员函数、全局函数）的二进制代码

### 为什么要内存对齐
CPU读取内存是按照chunk来进行的，如果一块内存大小是1字节，则所有内存都是对齐的，如果是4字节，如果没有内存对齐则一个4字节的数据可能要读多次。比如一个长度为4的数据从地址1开始存，CPU读取的粒度是4，则要读1234和5678内存的数据，然后再剔除合并，效率很低，如果是对齐的就可以一次就读出。

### 对齐的规则
```C++
struct test{
  int a;//从offset0开始4字节
  double b;//从8字节的整数倍开始8-15
  char c;//1字节整数倍还是1，所以是16+1=17字节，但不是8的整数倍，所以要补齐为24
};
struct test1{
  int a;//4字节
  test b;//最大元素为double b,所以从8的整数倍开始存8-31，
  double c;//8字节，32~39
  char d[100];//数组是分开存的，所以只取一个元素，40，但不是最大元素test b的整数倍，所以要补齐为48
};
```

### 如何让类只在堆/栈上创建对象
在栈上创建 `A a;`，在堆上创建`A* a = new A;`
- 只在堆上创建：每次在栈上创建对象编译器会检查析构函数能否调用，所以将析构函数设置为私有的就无法在栈上创建。为了能够让堆创建的对象能够正常析构，需要把delete定义为类的公有成员函数，然后在类外显式调用delete来释放空间。否则delete的时候会调用默认析构函数，但是析构函数已经被私有化了。
- 只在栈上创建：new A这个过程先调用`operator new()`来申请空间，然后调用构造函数进行初始化，所以可以在类内重载`operator new()`，并声明为私有，同时重载operator delete。

### C++类的内存布局
- 数据和函数分开存放，函数放在代码区，数据放在堆区、栈区、静态/全局区、文字常量区，实例化不同对象时，只给数据分配空间，各个对象调用函数时都跳转到函数在代码区的入口执行，可以节省拷贝多份代码的空间。
- 类的静态成员变量分配到静态/全局区，因此静态成员变量属于类，所有对象公用一份，不计入类的内存空间。static变量存在静态/全局区。
- 静态成员函数和非静态成员函数都放在代码区，都属于类，类可以直接调用静态成员函数，不可以直接调用非静态成员函数
- 内联函数也放在代码区，内联函数在被调用时，

### 指针和引用的区别
- 引用是变量的别名，底层实现是常量指针int *const，即指针不可修改，一旦指向某处就不能再指向别处
- 引用在定义的同时必须初始化，应用不能为空，指针可以为空
- 引用使用时无需解引用，指针需要

### 智能指针
- shared_ptr：管理的资源被多个对象共享，内部采用引用计数跟踪所有者的个数，最后一个所有者被析构时，资源释放。
- weak_ptr：shared_ptr有循环引用问题，所以引入weak_ptr。原理是一个shared_ptr A被赋值给shared_ptr B的时候，A引用+1，而A赋值给weak_ptr C时A的引用不会+1，弱引用会+1。weak_ptr的实现只是重载了赋值运算符，对weakref++。



### 变量的声明和定义有什么区别？
声明：指出存储类型，并给存储单元指定名称\
定义：分配内存空间，还可为变量指定初值\
extern关键字：通过extern关键字声明而不是定义变量。\
声明不一定是定义：`extern int val`只是声明了变量val但是没有分配空间，所以不是定义。**只有extern标识的才是声明，其它全是定义**
定义一定是声明：`int val`声明了变量val，也分配内存空间所以也是定义。\
声明可以有多个，但是定义只能有一个。

### 编译流程
- 预处理：将所有的#include和宏定义替换成其真正的内容，预处理之后得到的仍是**文本文件**（.i文件）
- 编译：将经过预处理之后的程序转换成特定**汇编代码**（.s文件）
- 汇编：将汇编代码转换成机器码，生成的是**可重定位的二进制文件**（.obj文件）
- 链接：将多个目标文件以及所需的库文件（.so等）链接成最终可执行文件
一个进程的虚拟地址空间，如下所示:\
ZONE_DMA：直接内存访问，占用16M，用于磁盘与内存的文件进行数据交换
![avatar](/img/bainyi.jpg)
- .bss文件为什么不能运行
因为缺少program header，操作系统不知道从哪去load程序
![avatar](/img/loadprogram.jpg)
### 智能指针

### static关键字
无论是全局静态变量还是局部静态变量，只要是**初始化**了的就在.data区，**未初始化**的就在.bss区。使用static的场景:
- （1）全局静态变量：全局变量前加static,作用域为其**所在的文件**，即它**对其他文件是不可见**的。
- （2）局部静态变量：在函数体中声明的静态变量，虽然**不会**随函数的结束而销毁，但是**作用域和函数体中其他变量是一样的**，在函数外不可见。下一次调用同样的函数时，其值会和上次保持一样。
- （3）静态函数：在函数名前面加上一个static即为静态函数，作用域为其所在的文件。
- （4）类中的静态**成员**：类中的静态成员需要在**类外初始化**，它不属于类的对象，而是属于类，所以使用它不需要this指针。
- （5）类中的静态成员函数：类中的静态函数也是属于整个类的，调用它也**不需要this指针**，所以静态函数体中也不能使用类的非静态成员（因为这个时候还没有对象，或者没有this指针不知道是哪个对象？）

### const在内存的哪里
被const修饰的是常量，不可修改，其约束的是编译器的行为，所以它在内存中的布局和普通变量一样在普通的变量区。

### int *const和const int *
**const在前**修饰的是解引用之后的内容，即**指针指向的对象**是const的；\
**const在后**修饰的是指针本身，即**指针地址**不可修改

### 成员函数后面加const
成员函数后面加const是**防止成员函数体内对成员对象进行修改**。与没有加const的函数属于**重载**，目的是让const对象调用const方法，非const对象调用非const方法。

### extern关键字
extern关键字表示其**修饰的变量或函数的定义在其源文件中**。
extern "C"表示接下来的内容按C语言的规则进行编译。比如C++编译器通过修改所有函数的名字来实现重载机制，C则是通过函数原本的名字来进行编译的。

### restrict
restrict,是C语言中的一种类型限定符（tpye qualifiers），用于告诉编译器，**对象已经被指针引用**，**不能**通过除该指针外所有其他之间或间接的方式来**修改该对象的内容**。

### 四种类型转换
- （1）reinterpret_cast：与C中的强制转换一样，没有任何限制
- （2）static_cast：用于各种隐式转换，用于void*与其他类型的指针之间的相互转换，**可用于多态父子类之间的转换但结果未知**
- （3）dynamic_cast：用于**父类指针**和**子类指针**，**父类引用和子类引用之间的转换**，若目标指针并非父类的子类，则会返回空，通过运行时类型推断实现的。
- （4）const_cast：用于将const类型转为非const类型。

### dynamic_cast
只能应用于指向类的指针或者引用上（或者void*），目的是确保目标指针类型所指向的是一个有效且完整的对象。
- 用途1：多态的基类指针->子类指针，将**多态的基类的指针**强制转化为**派生类的**指针，原理是通过虚函数表来获取运行时信息,因此基类一定要有虚函数。

```C++
class Base{virtual void dummy()};
class Derived:public Base{int a};
Base *pbase = new Derived;//多态基类指针
Base *pbase1 = new Base;
Derived *pderived = new Derived;//子类指针
Derived *p1;
Base *p2;
p1 = dynamic_cast<Derived*>(pbase);//可以转换，多态基类指针->子类指针
p1 = dynamic_cast<Derived*>(pbase1);//转换失败，pbase1实际指向的是一个基类对象
```

对于指针的转换如果失败则返回空指针，如果是引用则抛出bad_cast，对于指针可以用于判断该指针是否真的指向某个具体对象，如果是那个对象可以执行该对象的某个函数，比如用于扩展类的函数。
- 用途2：子类指针->基类指针，不需要基类有虚函数，一定会成功

### static_cast
可以做基类->子类和子类->基类，但是基类->子类不做类型检查。stati_cast可以用于所有能够隐式转换的情况。

### reinterpret_cast
不会进行类型检查，任何类型指针之间的转换

### const_cast
常量指针、对象、引用->非常量指针、对象、引用

### 隐式类型转换
没有显示类型转换的都是隐式转换，如①内置类型低精度的变量赋值给高精度的变量会发生隐式类型转换，②传给一个类的构造函数的变量若不是该类构造函数规定的参数类型的话也可能发生隐式类型转换。

### new/delete和malloc/free区别
- （1）new/delete是C++**关键字**，需要C++编译器支持。malloc/free是C**标准库函数**，需要包含相应头文件。
- （2）new分为两步，第一部分配内存，第二步调用构造函数；delete第一步调用析构函数，第二步释放内存。分配和释放内存底层使用malloc和free。
- （3）new返回的是**对象的指针**。malloc返回的是**void型指针**。
- （4）new失败后会抛出bad_alloc异常，并且可以使用set_new_handler设置new失败时的回调函数。malloc失败就返回空指针。

### C++类中可以定义应用数据成员吗？
可以，但必须使用初始化列表初始化

### 为什么用成员初始化列表会快一些
对于内置函数而言没有区别；对于用户定义的类而言，因为进入构造函数体后，所有对象都需要已经构造好，所以在之前会调用一次默认构造函数，然后在构造函数体内再调用一次特定的构造函数，这就会造成多调用了一次构造函数，损失效率。

### 菱形继承和虚继承
菱形继承：类A派生出B和C，A的成员变量和函数继承到D中变成两份，一份来自A->B->D另一份来自A->C->D。
![avatar](/img/lingxingderived.jpg)
D中如果对A的成员变量进行操作会引起歧义，如果在成员变量前加上`B::`或`C::`就可以避免这个情况，另一种方式是虚继承。
虚继承保证派生类（如D）中只保留一份间接基类（如A）的成员。
```C++
class A{
protected:
  int m_a;
};
class B:virtual public A{//虚继承
protected:
  int m_b;
};
class C:virtual public A{
protected:
  int m_c;
};
class D:public B, public C{
public:
  void seta(int a){m_a = a;}//没有问题，因为是虚继承只保留了一份a，如果不是虚继承需要改成B::m_a = a;
  void setb(int b){m_b = b;}
  void setc(int c){m_c = c;}
  void setd(int d){m_d = d;}
};
```


### 多态和虚函数
多态就是同一个操作作用于不同的对象可以产生不同的效果，在C++中使用虚函数来实现多态。虚函数调用是一种只知道部分信息完成工作的机制，用户只需要知道接口而不需要知道具体对象，具体实现是依赖虚函数表，**有虚函数的类**中会有一个**指向虚函数表的指针**，当一个**派生类**自己实现了父类的虚函数后，会将该函数在**继承到的虚函数表**中的**地址改**写为其**重写**的虚函数的地址。

### 虚函数和纯虚函数
- 虚函数：类成员方法的**声明**（不是定义），前面加virtual
- 纯虚函数：在虚函数后面加上“=0”
- 区别：
  - 1）对于**虚函数**子类可以选择重写或者不重写，对于**纯虚函数**，子类必须提供其实现，尽管基类可以给出纯虚函数的实现，但是无法通过指向子类对象的基类指针来调用该虚函数。
  - 2）含有纯虚函数的类叫**抽象类**，不能生成对象，只能用于创建派生类，如果**派生类中没有定义纯虚函数，则其仍然是抽象类**，否则是一个具体类
- 包含虚函数的类的内存布局
```C++
class D{
  void fun_a();
  virtual void func_b();
  int var;
};
```
![avatar](/img/class_virtual.jpg)
如果类里面**没有虚函数**，则函数存在代码区，数据存在堆区，每次根据对象的指针类型来决定调用函数。\
如果有虚函数则对象大小会多出4字节，虚函数表指针vptr，指向虚函数表vbtl，表中的数据是函数指针指向虚函数的位置。**普通函数、虚函数、虚函数表**都是一个类的所有对象共有，只有**成员变量和vptr**是对象私有的，所以sizeof对象的时候只包括var和vptr大小。
- 虚函数的实现：通过对象内存中的vptr找到vbtl，在通过vbtl中的函数指针找到对应虚函数的实现区域进行调用。

### 构造函数是否可以是虚函数？
不可以，**虚函数是通过对象内存中的vptr实现的**，构造函数是用来实例化一个对象的，构造函数完成前，vptr还没有初始化，因此也就找不到对应的虚函数位置。

析构函数，当使用delete a的时候，如果析构函数不是虚函数，则会调用基类的析构函数，而子类的成员没有析构，可能会内存泄漏。

### 内联函数可以是虚函数吗？
不可以，因为内联函数不能再运行中动态确定位置。

### 静态成员函数可以是虚函数吗？
不可以，静态成员函数不受限于某个对象

### 隐藏
子类的函数屏蔽与其同名的基类函数。
- 子类与基类函数同名，但是参数不同，不论是否有virtual，都隐藏基类函数
- 子类与基类函数同名，参数相同，但是基类函数没有virtual关键字，此时隐藏基类函数

### 静态链接和动态链接的区别
- 静态链接：在编译期完成，程序运行时与库函数无关，移植方便，浪费空间和资源，所有相关的目标文件都被链接成一个可执行文件。
- 动态链接：运行时载入库函数，节省空间，升级和更新方便

### 内联函数与宏的区别
内联函数是带了参数静态类型检查的宏，宏是预处理阶段展开的，内联函数是编译阶段处理的

### C实现多态
仿照linux中虚拟文件系统的做法，结构体中有一个op对象，里面都是各种函数指针，不同的文件系统实现不同的函数，然后赋值给该函数指针。

### 析构函数为何必须是虚函数？C++默认的为何不是虚函数？
delete父类指针时必须要调用子类的析构函数。通过基类指针销毁对象时，如果析构函数不是虚函数就不能正确识别对象类型，从而不能正确销毁对象，可能带来内存泄漏\
若默认析构函数是虚函数则每个类都需要引入虚函数表，没有必要。

### 静态多态和动态多态
**静态多态**通过**重载**和**模板**技术实现，在**编译的时候确定**。**动态多态**通过虚函数和继承关系实现，执行动态绑定，在**运行的时候确定**。

### 重载、重写、隐藏
- 重载：函数名和返回值相同，参数列表不同
- 重写：不同层级的类中实现不同的虚函数
- 隐藏：不同层级的类中实现的同名函数

### 析构函数
一个对象生命周期结束的时候会调用它的析构函数，析构函数调用顺序：派生类析构函数->成员对象的析构函数->父类析构函数

### 析构函数可以是纯虚函数吗
可以。

### 在main()函数之前执行的函数
静态成员的构造函数

### C语言函数调用流程
将函数参数压栈\
将函数返回值压栈\
将栈帧指针（ebp寄存器值）压栈\
移动栈顶和栈帧指针，为函数创建一个新的栈帧。

### C参数的压栈顺序
从右往左，对于可边长参数，从左往右编译器难以确定明确的参数地址，而从右往左，最左的参数地址就是栈帧指针加上一个返回值的长度。

### 拷贝构造函数
用一个类对象初始化另一个类对象时；\
函数参数值传递时;\
返回值类型为对象时。

### C++中拷贝构造函数的形参能否进行值传递
不能，因为使用形参会调用拷贝构造函数，造成循环调用。

### do while(0)的目的
让代码不受分号，大括号的影响

## STL

### STL组成部分
容器、迭代器、分配器、算法、仿函数、配接器

### STL内存池


### vector和list区别
都是线性容器，vector是顺序表支持随机访问，插入时间复杂度为O(n)，list是链表，只支持顺序访问，插入删除时间复杂度为O(1)。vector插入元素**超过预留内存**会向后继续扩张，并且每次扩张都是新建一个更大的vector然后把原来的复制过去，list不会。并且迭代器会失效

### map和set区别
map是键值对容器，map的迭代器key不可修改，value可修改；\
set是数据集合，迭代器不可修改。

### map的key如果是结构体需要重载<运算符

### 上千万数据的map如何释放内存
因为小于128byte的内存数据是用二级配置器申请的，使用完后会放回内存池，并没有真正释放，所以需要和临时空map对象swap后销毁临时map对象。

### STL的allocator
是STL中广泛使用的对象配置器，提高了对象创建和销毁的效率。\
STL为了分工精细，使用配置器分配内存，使用construct和destroy函数处理对象的构造和析构，construct使用`placement new(*p, class T)`来在指定为位置创建对象。配置器分为两层，当所需内存小于128byte时调用二级配置器，其使用了内存池技术，以8byte为单位分了16种大小的槽位，每个槽位管理一个空闲链表，当空闲链表中没有空闲内存块时则从内存池中取一定数量的内存块放到空闲链表中。这里的空闲链表并没有多占用一点内存，其将next指针和内存块的头数据放在一个union中，避免了内存浪费。

### STL迭代器删除元素
STL使用erase删除迭代器内容。对于序列容器（vector、deque），erase返回所删除的迭代器的下一迭代器，但删除迭代器元素会导致后面迭代器均失效。对于关联容器，erase会导致被删除的迭代器失效，但是其它迭代器内容不失效，对于list来说，erase会返回下一迭代器，且其它迭代器均不失效。

### 迭代器的作用
迭代器的主要作用是将容器和算法分离，迭代器让容器的数据访问和遍历操作一致，这样算法使用迭代器对数据进行操作和遍历就不需要关心具体的容器类型，适用性更强。

### 迭代器失效

迭代器失效分三种情况考虑，也是分三种数据结构考虑，分别为数组型，链表型，树型数据结构。

数组型数据结构：该数据结构的元素是分配在连续的内存中，insert和erase操作，都会使得删除点和插入点之后的元素挪位置，所以插入点和删除掉之后的迭代器全部失效，也就是说insert(*iter)(或erase(*iter))，然后在iter++，是没有意义的。解决方法：erase(*iter)的返回值是下一个有效迭代器的值。 iter =cont.erase(iter);

链表型数据结构：对于list型的数据结构，使用了不连续分配的内存，删除运算使指向删除位置的迭代器失效，但是不会失效其他迭代器.解决办法两种，erase(*iter)会返回下一个有效迭代器的值，或者erase(iter++).

树形数据结构：使用红黑树来存储数据，插入不会使得任何迭代器失效；删除运算使指向删除位置的迭代器失效，但是不会失效其他迭代器。erase迭代器只是被删元素的迭代器失效，但是返回值为void，所以要采用erase(iter++)的方式删除迭代器。

### resize和reserve
resize改变的是size值，变小则后面的元素丢掉，变大则后面元素默认初始化。\
reserve改变的是容量，不增加元素。

### 编译

C++源文件到可执行文件的过程\
C++源文件->(预处理)->宏展开后的源文件->(编译阶段)->汇编文件->(汇编阶段)->可重定位的二进制文件->(链接阶段)->可执行文件

### define与const区别

- #define是宏定义，在预处理阶段会直接进行替换，全局有效，不做类型检查，没有作用域限制，可能会污染全局变量
- const是编译器处理的，有类型检查，有作用域限制，不会污染全局变量。但是由于宏替换的方式，使得编译过程变慢（预编译+编译），但程序运行变快，因为早就已经替换好了，直接运行就可以了，而const编译时间少，但是运行速度慢，因为要找内存空间去开辟变量。
- #define可以定义表达式，const不能

### 堆栈区别

- 栈：存放的是函数的参数、局部变量、返回值地址。每次调用函数都会使用一个新的栈，存放函数的调用信息和返回类型，和临时变量。栈空间从高位向低位地址增长，一块连续的内存，最大容量是预定的。
- 堆：动态分配内存，由程序员申请分配和释放

- 栈：栈是线程**创建时**分配好的内存空间，在**sp寄存器**里存放**栈顶**地址。在栈中分配一个n字节的空间只需要把**sp的值减去n**(栈从高地址向低地址增长)，几乎没有开销。每次调用函数时，会将**返回地址**和**当前栈指针(sp)的值压栈，形成一个新的栈帧**，当前栈指针的值会被存入bp寄存器中，标识栈帧的起始地址。函数返回时，sp被设置为bp的值，相当于将该栈帧内的内容全部弹出，然后弹出返回地址并跳转到该位置。原本存储在被弹出栈帧内的内容虽然还在原本的内存地址，但随时可能被其它内容覆盖。

- 堆：而堆位于内存空间中，代码和数据之后的位置，由内存分配器(如malloc函数内的)负责管理。在堆中分配和回收内存时，内存分配器会执行一定的算法来避免出现大量碎片。在不同平台上，算法的策略可能不一样(时间和空间上取舍)，x86上可能是O(logn)的复杂度，n为内存块数。堆的初始大小有限，当内存分配器无法分配指定大小的内存块时，将使用一个系统调用(如Linux下的sbrk)扩大堆的大小，堆的大小上限与很多因素有关，但通常远大于栈。

### struct和class区别

- 默认继承访问权限。class默认是private，struct默认是public
- 默认访问权限。class作为**对象**的实现体，默认的成员变量访问控制是private。struct作为**数据结构**的实现体，默认的数据访问控制是public的。

## 网络编程
### 判断是长链接还是短连接
### 浏览器断点续传

### Reactor模型
一般来说，reactor模型有三种角色，一个是accptor，一个是reactor，一个是handler。通过acceptor向reactor注册关注的事件，事件发生时，reactor将事件交给相应的handler处理执行相关的业务逻辑。**本质上是将关注的事件与相应回调函数关联，事件发生时执行相应的回调函数**\
与Proactor核心区别是Reactor处理的是**未完成IO的事件**，而Proactor处理的是已经完成IO的事件或信号。

### TCP的connect函数
TCP中的connect函数用于三次握手建立TCP连接。\
阻塞方法：发送SYN报文段，收到SYN、ACK报文段之后，发送ACK报文段然后返回。\
非阻塞方法：首先判断返回值，-1的话检查错误码，如果是ENTER，则重新connect，如果是EINPROGRESS，则说明正在连接中，其余错误码则说明连接出现错误。之后用epoll检查是否有写事件发生（accept检查读事件），如有写事件则用getsockopt检查错误，没有错误则连接成功。

### read和write
#### read
- 阻塞与非阻塞：\
阻塞的read在有数据时返回，没有数据时阻塞。非阻塞的read在没有数据时返回-1，错误码为EAGAIN或EWOULDBLOCK(其实也是EAGIN #define EWOULDBLOCK EAGAIN)
- 返回值：\
大于0->正常\
等于0->读到FIN，关闭连接；\
小于0->错误码为EINTR表示被信号中断，一般会重新调用read。错误码为EAGAIN表示当前没有数据。

#### write
- 阻塞与非阻塞：\
阻塞的write在缓冲区空间组已发送所有数据时才返回。\
非阻塞的wirte在缓冲区空间不够时只写一部分，然后返回写了的长度，之后再调用则返回-1，错误码EAGAIN或EWOULDBLOCK。
- 返回值：
大于0->正常\
等于0->套接字已经关闭\
小于0->错误码为EINTR表示被信号中断，一般会重新调用write，错误码为EAGAIN表示当前缓冲区没有空间。
### HTTPS如何握手的
- 1、客户端发起https请求
- 2、服务器响应客户端，并把CA签发的服务器证书，这个证书包括**用CA私钥对服务器公钥加密后的密文和对服务器公钥的hash后的摘要**发给客户端
- 3、客户端验证公钥有效性（客户端拿到服务器发来的证书，从本地的CA根证书中获取CA公钥，对服务器证书的密文进行解密，获取服务器公钥，并对次进行一次hash，比较得到的结果与证书携带的是否一致，为了防止公钥被篡改）
- 4、验证有效之后客户端会生成一个会话密钥，用服务器的公钥对这个会话密钥进行加密，然后发给服务器
- 5、服务器收到后用私钥解密，获取会话密钥
- 6、客户端与服务器通过会话密钥进行对称加密通信
![avatar](/img/https.jpg)
- 总结：用对称加密进行通信，用非对称加密传输对称加密的密钥，数字证书保证非对称加密的公钥是可信的，用hash来保证服务器公钥没有被篡改。

### https可以被抓包吗？
会被抓包，https只是防止用户在不知情的情况下通信被监听，但如果用户主动授信，是可以构建中间人网络的，代理软件可以对传输内容进行解密。

### get和post区别
- 都包含请求头请求行，post多了请求body。
- get多用来查询，请求参数放在url中，不会对服务器上的内容产生作用。
- post用来提交，如把账号密码放入body中。
- GET是直接添加到URL后面的，直接就可以在URL中看到内容，而POST是放在报文内部的，用户无法直接看到。
- GET提交的数据长度是有限制的，因为URL长度有限制，具体的长度限制视浏览器而定。而POST没有。

### TCP与UDP的区别
- TCP(Transmission Control Protocol，传输控制协议)：是面向连接的，提供可靠交付，有流量控制，拥塞控制，提供全双工通信，面向字节流（把应用层传下来的报文看成字节流，把字节流组织成大小不等的数据块），每一条TCP连接只能是点对点的（一对一）。
- UDP(User Datagram Protocol，用户数据报协议)：是无连接的，尽最大可能交付，没有拥塞控制，面向报文（对于应用程序传下来的报文不合并也不拆分，只是添加UDP首部），支持一对一、一对多、多对一和多对多的交互通信。

### TCP、UDP首部格式
- 首部格式UDP首部只有8字节包括源端口、目的端口、长度、校验和
- TCP首部有20字节固定首部
### TCP如何保证可靠性
- （1）校验和：保证数据没有在传输中发生变化
- （2）序列号(seq)和确认号(ack)机制，超时重传：保证数据的送达
- （3）流量控制：保证接收方缓存足够接收数据
- （4）拥塞控制：保证数据发送不引起网络拥堵
- （5）三次握手四次挥手：保证连接和断开时的可靠

### TCP的粘包
- 定义：发送方的若干包数据到接收方接收时粘成一包，从接收缓冲区看就是后一包数据的头紧跟着前一包数据的尾。UDP是不会发生粘包的，粘包问题在数据链路层、网络层、传输层都可能发生，UDP是基于报文发送的，UDP首部用了16bit来指示UDP数据报文的程度，因此有数据边界不会粘包。但是TCP是面向数据流的，**首部没有表示数据长度的字段**，所以会粘包。
- 粘包发生的场景：TCP是面向字节流的，没有边界，但是操作系统在**发送**TCP数据时会用缓冲区进行优化，如果一次请求发送的数据量较小，没到缓冲区大小，TCP会将多个请求合并为一个请求进行发送，这就形成了粘包。或者**接收端**没有及时处理缓存中的数据
- 解决方案：
  - 发送端固定包长度，如100字节，不足的补充0
  - 发送端每个包末尾使用固定的分隔符，如\r\n。如果发生拆包需要等待多个包都发过来之后找到\r\n再合并；例如FTP协议
  - 将消息分为头部和消息体，头部保存长度，只有读取到足够长度的消息之后才算是读取到了一个完整的消息。

### TCP滑动窗口

如果为每个数据包都确认一次，包的往返时间越长，网络吞吐量会越低。滑动窗口是指**无需等待确认应答就可以继续发送数据的最大值**。如果有ack丢失，可以通过下一个确认应答进行确认，这个模式叫累积确认，即每次确认的都是这个确认号之前所有的数据。\
如果发送窗口内左端的字节**已经发送并收到确认**则右移窗口直到左端第一个字节**不是**已发送且确认状态。\
接收窗口只对窗口内最后一个**按序到达**的字节进行确认，例如收到{31,34,35}则只对31去人，**发送方**得到第一个字节被确认之后就认为之前的所有字节都被接收了。
![avatar](/img/滑动窗口.jpg)


### 拥塞控制
- 慢启动：将拥塞窗口大小设定为1MSS（maximum segment size，发送者最大段大小），每个ACK到来就将拥塞窗口大小+1MSS。该状态**拥塞窗口呈指数增大**，每个RTT(round-trip time)增大一倍。慢启动的理由是**TCP刚开始发送数据时并不知道网络的实际情况，需要试探的方式平滑地增加拥塞窗口大小**，但是指数方式并不平滑，所以有**慢启动门限**，超过这个值会进入拥塞避免。

- 拥塞避免：拥塞避免使用CWND按照线性方式增加，从而减缓其扩大。

- 快重传与快恢复：实际是相对慢启动而言，拥塞窗口不是从1开始，而是从当前窗口的一半开始执行拥塞避免算法。
在 TCP/IP 中，快速重传和恢复（fast retransmit and recovery，FRR）是⼀种拥塞控制算法，它能快速恢复丢失的数据包。没有 FRR，如果数据包丢失了，TCP 将会使⽤定时器来要求传输暂停。在暂停的这段时间内，没有新的或复制的数据包被发送。有了 FRR，如果接收机接收到⼀个不按顺序的数据段，它会⽴即给发送机发送⼀个重复确认。如果发送机接收到三个重复确认，它会假定确认件指出的数据段丢失了，并⽴即重传这些丢失的数据段。有了FRR，就不会因为重传时要求的暂停被耽误。当有单独的数据包丢失时，快速重传和恢复（FRR）能最有效地⼯作。当有多个数据信息包在某⼀段很短的时间内丢失时，它则不能很有效地⼯作。

### 浏览器输入url之后发生了什么？
![avatar](/img/url.png)

### 拥塞发生时拥塞控制的行为
#### 如何判断拥塞发生？
拥塞可能发生在慢启动或拥塞避免阶段。判断拥塞发生的依据
- 传输超时，或者说TCP重传定时器溢出。
- 接收到重复的ACK。\
对第一种情况仍然使用慢启动和拥塞避免，**但慢启动门限阈值设为之前的一半**，第二种情况使用快重传和快回复。如果第二种情况发生在**超时**之后也按第一种情况处理。

### 为啥不能是两次握手？
两次握手意味着服务端接收到**SYN报文段**之后即认为连接已经建立，并为其维护相关系统资源。但客户端发送SYN报文段之后可能由于网络**原因服务端**的SYN、ACK报文段并**没有送达客户端**，此时**客户端不认为**连接已经建立也不会发送数据，而**服务端将维护相关系统资源**一段比较长的时间，造成浪费。

### 为啥不用四次？
TCP是全双工通信，原本的握手模型确实应该像挥手一样进行四次，但是服务端回复ACK和发送SYN之间并没有联系，所以可以合并为一次发送，故握手只需要三次。

### TCP三次握手初始序列号为什么不用固定值？
防止串话，防止**上一个连接**的数据包在**本次连接建立后**才传来，并且在同一个窗口中

### TCP的保活
服务端每过一段时间（两小时）会发送一个心跳包（ACK报文段，序号为当前序号-1），正常情况下客户端回一个ACK，如果客户端异常掉线，则服务端每过一定时间（1000ms）发送一次心跳包，重复一定次数后关闭连接， 

### TIME_WAIT作用
- （1）可靠地终止TCP连接。实际上是**确保最后一个ACK到达服务器，从而让服务器关闭连接**。
- （2）**保证让迟来的TCP报文段有足够的时间被识别并丢弃**。报文段在网络中最大生存时间是MSL，等待2MSL是为了避免之前的连接的分组，进入新的连接中造成串话。

### 为啥是2MSL
- 保证客户端的最后一个ACK在一个MSL消逝之后，服务端超时重传的FIN报文段在1个MSL内发过来能被客户端接收到。
- 防止已失效的报文出现在新的连接中。

### 出现大量CLOSE_WAIT原因以及处理方法
CLOSE_WAIT出现在服务端收到FIN报文，但一直没有回送FIN报文的时候，一般是**因为服务器处于忙读等状态**，所以要处理好断开连接的情况，**在read返回值为0**或者**返回值小于0且errno不是EAGAIN**就断开连接（是被其他信号中断了？）。

### SYN洪范攻击
攻击者发送大量的SYN报文段，而不完成第三次握手，随着SYN报文段到来，服务器会不断为这些半开连接分配资源，导致服务器资源耗尽。\
防御手段：SYN cookie服务器收到一个SYN报文段时，服务器不会为该报文段生成一个半开连接，相反，服务器会生成一个初始TCP序列号，该序列号是**SYN报文段**的**源**和**目的**IP地址与端口号通过**只有服务器知道**的哈希函数计算得到。重要的是，服务器并**不记忆该cookie或者任何应于SYN的其他状态信息**（三次握手的时候是分配了缓存和变量，即记录了状态信息）\
如果客户是合法的，那么客户会返回一个ACK，服务器收到ACK之后需要验证该ACK是否与前面发送的某些SYN对应（三次握手不需要验证因为分配了缓存和变量）。具体做法是将ACK报文段中的源和目的地IP地址与端口号执行同样的哈希函数，如果结果+1与SYNACK报文段中的确认号相同，则认为该ACK对应前面的SYN，是合法的，生成一个具有套接字的全开连接。
![avatar](/img/synattack.jpg)

### IP和MAC地址作用
MAC地址是硬件地址，由链路层负责，IP是网络层IP协议提供地址格式，是网络中每一个节点的逻辑地址，用以屏蔽硬件地址的差异。

### http长连接和短连接？
在HTTP/1.0中默认使⽤短连接。也就是说，客户端和服务器每进⾏⼀次HTTP操作，就建⽴⼀次连接，任务结束就中断连接。当客户端浏览器访问的某个HTML或其他类型的Web⻚中包含有其他的Web资源（如
JavaScript⽂件、图像⽂件、CSS⽂件等），每遇到这样⼀个Web资源，浏览器就会重新建⽴⼀个HTTP会话。
⽽从HTTP/1.1起，默认使⽤⻓连接，⽤以保持连接特性。使⽤⻓连接的HTTP协议，会在响应头加⼊这⾏
代码：
`Connection:keep-alive`
在使⽤⻓连接的情况下，当⼀个⽹⻚打开完成后，客户端和服务器之间⽤于传输HTTP数据的TCP连接不会关闭，客户端再次访问这个服务器时，会继续使⽤这⼀条已经建⽴的连接。Keep-Alive不会永久保持连接，它有⼀个保持时间，可以在不同的服务器软件（如Apache）中设定这个时间。实现⻓连接需要客户端和服务端都⽀持⻓连接。
**HTTP协议的⻓连接和短连接，实质上是TCP协议的⻓连接和短连接。**

### http是不保存状态的协议，如何知道用户状态？
HTTP 是⼀种不保存状态，即⽆状态（stateless）协议。也就是说 HTTP 协议⾃身不对请求和响应之间的通信状态进⾏保存。那么我们保存⽤户状态呢？Session 机制的存在就是为了解决这个问题，Session 的主要作⽤就是通过服务端记录⽤户的状态。典型的场景是购物⻋，当你要添加商品到购物⻋的时候，系统不知道是哪个⽤户操作的，因为 HTTP 协议是⽆状态的。服务端给特定的⽤户创建特定的Session 之后就可以标识这个⽤户并且跟踪这个⽤户了（⼀般情况下，服务器会在⼀定时间内保存这个Session，过了时间限制，就会销毁这个Session）。
在服务端保存 Session 的⽅法很多，最常⽤的就是内存和数据库(⽐如是使⽤内存数据库redis保存)。既然 Session 存放在服务器端，那么我们如何实现 Session 跟踪呢？⼤部分情况下，我们都是通过在
Cookie 中附加⼀个 Session ID 来⽅式来跟踪。
#### Cookie 被禁⽤怎么办?
最常⽤的就是利⽤ URL 重写把 Session ID 直接附加在URL路径的后⾯，所以cookie被禁用session仍可以工作。
### cookie和session的区别
http是无状态协议，后果是每次刷新网页都要重新输入账号密码，解决方案是给客户端提标签。一个cookie就是一个变量，如`name=value`，存储在浏览器；一个session是一个数据结构，如键值对，存储在服务器。
- cookie:服务器通过http的setcookie在设置cookie，客户端接收到之后的http通信就可以携带这个cookie，通信中就可以让服务器识别。但是有些网站结构复杂，cookie无法存储，而且cookie在http header中会消耗很多带宽
- session:session可以承载各种数据，存放在**服务器上**，客户端的cookie传输一个session ID就可以找到对应的session，认出这个客户
- 所以有如下区别：
  - 存储位置不同：cookie存在客户端浏览器上，session存在服务器上
  - 存储容量不同：cookie保存的数据≤4kb,一个站点最多保存20个cookie；session没有上限，为了不占用过多的服务器资源会设置过期删除机制
  - 存取方式不同：cookie只能保管ASCII字符串，需要通过编码的方式存续Unicode字符或者二进制数据，运行cookie难以实现存储略微复杂的信息
  - 隐私策略不同：cookie对服务端是可见的，别有用心的人可以分析放在本地的cookie进行cookie诈骗，所以是不安全的
  - 服务器压力不同：Session保存在服务端，每个用户都产生一个session，如果并发用户十分多，会消耗大量内存，cookie存在客户端不会有这个问题。

区别：
Cookie 和 Session都是⽤来跟踪浏览器⽤户身份的会话⽅式，但是两者的应⽤场景不太⼀样。Cookie ⼀般⽤来保存⽤户信息 ⽐如①我们在 Cookie 中保存已经登录过得⽤户信息，下次访问⽹站的
时候⻚⾯可以⾃动帮你登录的⼀些基本信息给填了；②⼀般的⽹站都会有保持登录也就是说下次你再访问⽹站的时候就不需要重新登录了，这是因为⽤户登录的时候我们可以存放了⼀个 Token 在 Cookie
中，下次登录的时候只需要根据 Token 值来查找⽤户即可(为了安全考虑，重新登录⼀般要将 Token重写)；③登录⼀次⽹站后访问⽹站其他⻚⾯不需要重新登录。
Session 的主要作⽤就是通过服务端记录⽤户的状态。 典型的场景是购物⻋，当你要添加商品到购物⻋的时候，系统不知道是哪个⽤户操作
的，因为 HTTP 协议是⽆状态的。服务端给特定的⽤户创建特定的 Session 之后就可以标识这个⽤户并且跟踪这个⽤户了。
Cookie 数据保存在客户端(浏览器端)，Session 数据保存在服务器端。
Cookie 存储在客户端中，⽽Session存储在服务器上，相对来说 Session 安全性更⾼。如果要在Cookie 中存储⼀些敏感信息，不要直接写⼊ Cookie 中，最好能将 Cookie 信息加密然后使⽤到的时候再去服务器端解密。

### IP层如何知道报文该给哪个应用程序，如何区分TCP还是UDP报文
多路分解：IP数据报头部记录了协议标识，传输层报文头记录了目的端口号。

### IP数据包的内容
![avatar](/img/ippackage.jpg)
- 4位版本号记录IP协议版本
- 4位头部长度，表示该IP头部有多少个32bit，4位最多表示15所以包最长是60字节
- 16位数据包总长度，ip数据包最长为65535字节，但由于MTU限制，超出MTU会分片
- 8位生存时间TTL(Time to Live)，数据包到达目的地之前允许经过的路由器的跳数。
- 8位协议区分上层协议是ICMP TCP UDP

### DNS解析流程
主机询问本地域名服务器是否知道被查询域名的IP，这个过程是**递归**（本地域名服务器代替主机继续查询），本地域名服务器向**根域名服务器查询**，这个过程是**迭代**（根域名服务器告诉本地域名服务器下一个应该去哪查找）

### https与http区别？
1. 端⼝ ：HTTP的URL由“http://”起始且默认使⽤端⼝80，⽽HTTPS的URL由“https://”起始且默认使⽤端⼝443。
2. 安全性和资源消耗： HTTP协议运⾏在TCP之上，所有传输的内容都是明⽂，客户端和服务器端都
⽆法验证对⽅的身份。HTTPS是运⾏在SSL/TLS之上的HTTP协议，SSL/TLS 运⾏在TCP之上。所有传输的内容都经过加密，加密采⽤对称加密，但对称加密的密钥⽤服务器⽅的证书进⾏了⾮对称加密。所以说，HTTP 安全性没有 HTTPS⾼，但是 HTTPS ⽐HTTP耗费更多服务器资源。
对称加密：密钥只有⼀个，加密解密为同⼀个密码，且加解密速度快，典型的对称加密算法有DES、AES等；
⾮对称加密：密钥成对出现（且根据公钥⽆法推知私钥，根据私钥也⽆法推知公钥），加密解密使⽤不同密钥（公钥加密需要私钥解密，私钥加密需要公钥解密），相对对称加密速度教慢，典型的⾮对称加密算法有RSA、DSA等。

### https与http
https在http基础上加入了SSL/TLS协议，SSL/TLS依靠证书来验证服务器身份，并为浏览器和服务器之间提供加密通信。HTTPS访问服务器的流程：
- 用户向服务器发起安全连接请求
- 服务器返回经过CA（certificate authority）认证的数字证书，证书里包含了服务器的public key
- 用户拿到数字证书，用自己浏览器内置的CA证书解密得到服务器的public key
- 用户用服务器的public key加密接下来用于**对称加密**的密钥，传给服务器
- 服务器通过private key解密，获取对称加密的密钥，和用户进行接下来的加密通信

### http与TCP
- TCP是传输层协议，定义数据传输和连接方式的规范。握手过程不传输数据，握手完成后才开始传输数据。
- http是超文本传输协议是应用层的协议，定义传输内容规范，http的数据是利用TCP传输的，客户端发送的每次请求都需要服务器响应，默认使用80端口，请求结束后会主动释放连接。

![avatar](/img/http.jpg)

### http1.0、http1.1、
- http1.0是无状态无连接的协议，每次请求都建立一个tcp连接处理完之后断开连接（无连接），服务器不跟踪每个客户，不记录过去的请求（无状态）。可以用cookie/session机制来做身份认证和状态记录
- http1.0存在的问题：无法复用连接，队头阻塞，
- http1.1使用了Connection字段，通过设置keep-alive保持http连接不断，但管道机制虽然可以同时发多个请求，但是每个请求必须是按序完成的。
- http2.0：多路复用（双工通信），一个http2.0连接里，客户端和服务器都可以同时发多个请求和响应，而不用按照顺序一一对应，避免了队头阻塞。

### http状态码和方法
![avatar](/img/httpstate.png)
![avatar](/img/httpstateall.jpg)
![avatar](/img/httpmethod.png)

## 操作系统
### 什么是操作系统？
1. 操作系统（Operating System，简称 OS）是管理计算机硬件与软件资源的程序，是计算机系统的内核与基⽯；
2. 操作系统本质上是运⾏在计算机上的软件程序；
3. 操作系统为⽤户提供⼀个与系统交互的操作界⾯；
4. 操作系统分内核与外壳（我们可以把外壳理解成围绕着内核的应⽤程序，⽽内核就是能操作硬件的程序）。

### 系统调用
根据进程访问资源的特点，我们可以把进程在系统上的运⾏分为两个级别：
1. ⽤户态(user mode) : ⽤户态运⾏的进程或可以直接读取⽤户程序的数据。
2. 系统态(kernel mode):可以简单的理解系统态运⾏的进程或程序⼏乎可以访问计算机的任何资源，不受限制。\
用户程序凡是与系统态级别的资源有关的操作（如文件管理、进程控制、内存管理等），都必须通过系统调用的方式向操作系统提出服务请求，由操作系统代为完成。系统调用大致可分为如下几类：
   - 设备管理。完成设备的请求或释放，以及设备启动等功能。
   - ⽂件管理。完成⽂件的读、写、创建及删除等功能。
   - 进程控制。完成进程的创建、撤销、阻塞及唤醒等功能。
   - 进程通信。完成进程之间的消息传递或信号传递等功能。
   - 内存管理。完成内存的分配、回收以及获取作业占⽤内存区⼤⼩及地址等功能。

### 进程有几种状态
- 创建状态(new) ：进程正在被创建，尚未到就绪状态。
- 就绪状态(ready) ：进程已处于准备运⾏状态，即进程获得了除了处理器之外的⼀切所需资源，⼀旦得到处理器资源(处理器分配的时间⽚)即可运⾏。
- 运⾏状态(running) ：进程正在处理器上上运⾏(单核 CPU 下任意时刻只有⼀个进程处于运⾏状态)。
- 阻塞状态(waiting) ：⼜称为等待状态，进程正在等待某⼀事件⽽暂停运⾏如等待某资源为可⽤或等待 IO 操作完成。即使处理器空闲，该进程也不能运⾏。
- 结束状态(terminated) ：进程正在从系统中消失。可能是进程正常结束或其他原因中断退出运⾏
![avatar](/img/process.png)

### 进程间通信
1. 管道/匿名管道(Pipes) ：⽤于具有亲缘关系的⽗⼦进程间或者兄弟进程之间的通信。
2. 有名管道(Names Pipes) : 匿名管道由于没有名字，只能⽤于亲缘关系的进程间通信。为了克服这个缺点，提出了有名管道。有名管道严格遵循先进先出(first in first out)。有名管道以磁盘⽂件的⽅式存在，可以实现本机任意两个进程通信。
3. 信号(Signal) ：信号是⼀种比较复杂的通信⽅式，⽤于通知接收进程某个事件已经发⽣；
4. 消息队列(Message Queuing) ：消息队列是消息的链表,具有特定的格式,存放在内存中并由消息队列标识符标识。管道和消息队列的通信数据都是先进先出的原则。与管道（⽆名管道：只存在于内存中的⽂件；命名管道：存在于实际的磁盘介质或者⽂件系统）不同的是消息队列存放在内核中，只有在内核重启(即，操作系统重启)或者显示地删除⼀个消息队列时，该消息队列才会被真正的删除。消息队列可以实现消息的随机查询,消息不⼀定要以先进先出的次序读取,也可以按消息的类型读取.⽐ FIFO 更有优势。**消息队列克服了信号承载信息量少，管道只能承载⽆格式字节流以及缓冲区⼤⼩受限等缺点**。
5. 信号量(Semaphores) ：信号量是⼀个计数器，⽤于多进程对共享数据的访问，信号量的意图在于进程间同步。这种通信⽅式主要⽤于解决与同步相关的问题并避免竞争条件。
6. 共享内存(Shared memory) ：使得多个进程可以访问同⼀块内存空间，不同进程可以及时看到对⽅进程中对共享内存中数据的更新。这种⽅式需要依靠某种同步操作，如互斥锁和信号量等。可以说这是最有⽤的进程间通信⽅式。
7. 套接字(Sockets) : 此⽅法主要⽤于在客户端和服务器之间通过⽹络进⾏通信。套接字是⽀持TCP/IP 的⽹络通信的基本操作单元，可以看做是不同主机之间的进程进⾏双向通信的端点，简单的说就是通信的两⽅的⼀种约定，⽤套接字中的相关函数来完成通信过程。

### kill-9之后发生了什么？


### 线程间同步方式？
1. 互斥量(Mutex)：采⽤互斥对象机制，只有拥有互斥对象的线程才有访问公共资源的权限。因为互斥对象只有⼀个，所以可以保证公共资源不会被多个线程同时访问。
1. 信号量(Semphares) ：它允许同⼀时刻多个线程访问同⼀资源，但是需要控制同⼀时刻访问此资源的最⼤线程数量
3. 事件(Event) :Wait/Notify：通过通知操作的⽅式来保持多线程同步，还可以⽅便的实现多线程优先级的⽐较。

### 操作系统中的进程调度算法？
- 先到先服务(FCFS)调度算法 : 从就绪队列中选择⼀个最先进⼊该队列的进程为之分配资源，使它⽴即执⾏并⼀直执⾏到完成或发⽣某事件⽽被阻塞放弃占⽤ CPU 时再重新调度。
- 短作业优先(SJF)的调度算法 : 从就绪队列中选出⼀个估计运⾏时间最短的进程为之分配资源，使它⽴即执⾏并⼀直执⾏到完成或发⽣某事件⽽被阻塞放弃占⽤ CPU 时再重新调度。
- 时间⽚轮转调度算法 : 时间⽚轮转调度是⼀种最古⽼，最简单，最公平且使⽤最⼴的算法，⼜称 RR(Round robin)调度。每个进程被分配⼀个时间段，称作它的时间⽚，即该进程允许运⾏的时间。
- 多级反馈队列调度算法 ：前⾯介绍的⼏种进程调度的算法都有⼀定的局限性。如短进程优先的调度算法，仅照顾了短进程⽽忽略了⻓进程 。多级反馈队列调度算法既能使⾼优先级的作业得到响应⼜能使短作业（进程）迅速完成，因⽽它是⽬前被公认的⼀种较好的进程调度算法，UNIX 操作系统采取的便是这种调度算法。
- 优先级调度 ：为每个流程分配优先级，⾸先执⾏具有最⾼优先级的进程，依此类推。具有相同优先级的进程以 FCFS ⽅式执⾏。可以根据内存要求，时间要求或任何其他资源要求来确定优先级。



### 用户态和内核态
- 仅在内核态下才能使用的指令称为**特权指令**，执行这些指令不经会影响运行程序自身，还会干扰其他程序以及操作系统。非特权指令在内核态和用户态下都能工作。
- 通过程序状态字（PSW）来将处理器的状态设置为内核或用户态
- 单一用户单一服务的操作系统不区分用户态和内核态，用户态和内核态是为了处理多用户多任务，通过硬件手段，限制某些代码，使其无法控制整个物理硬件，进而使不同用户，不同任务的代码无权修改整个物理硬件，进而保护操作系统的核心底层代码和其他用户的数据不被破坏或盗取。
- 内核态是操作系统管理程序执行时所处的状态，能够执行包含特权指令在内的一切指令，能够访问系统内所有的存储空间。
- 用户态是用户程序执行时处理器所处的状态，不能执行特权指令，只能访问用户地址空间。

### 用户态和内核态的切换

处理器从用户态切换到内核态的方法：**系统调用**、**异常**、**外部中断**
- 系统调用是操作系统的最小功能单位，是操作系统提供的用户接口，系统调用本身是一种**软中断**
- 异常，是由错误引起的如文件损坏、缺页故障等。
- 外部中断，通过两根信号线来通知处理器外设的状态变化，是**硬中断**

### 中断分类
- 外中断：来自处理器之外的中断信号，如时钟中断、键盘中断
- 内中断：来自处理器内部的中断信号，如硬件故障中断、程序性中断

### 并行和并发
并发强调的是一起出发，并行强调的是一起执行\
与**并发**相对的是**顺序**：\
并发：无论上一个任务是否完成，当前任务都可以开始执行\
顺序：上一个开始执行的任务完成后，当前任务才能开始执行\
与**并行**相对应的是**串行**：\
串行：有一个任务执行单元从物理上只能一个任务接着一个任务的执行。\
并行：有多个任务执行单元从物理上可以多个任务一起执行。\
因此并行与并发并不是互斥概念，并发关注的是任务的抽象调度，并行关注的是任务的实际执行，它们又是相关的，比如并行一定允许并发。\
- 单核CPU多任务：并发（不用等上一个任务执行完才开始下一个任务）、串行（只有一个实际执行的CPU核）
- 多线程：并发、串行（所有线程都在同一个核上执行）；并发、并行（不同线程在不同核上执行）

### 为什么要并发？
如果是4个线程4个核心，则是并行，如果只有1个核心实际上4个线程也是串行执行的，但是设计程序的时候要**尽可能让程序能够并行**


### 进程和线程的区别
- 1、启动新的进程必须分配独立的地址空间，建立众多的数据表来维护它的代码段、堆栈段和数据段，系统**开销较大**，而线程之间使用相同的地址空间，共享大部分数据，切换的速度也比进程快，效率高，linux中线程和进程共用一个数据结构struct_task，所以linux中线程也就是lwp（轻量级进程），开一个进程和线程底层使用的都是clone函数，只是共享的数据不同，线程共享大部分数据。
- 2、由于进程间独立的特点，进程安全性比较高，也因为进程有独立的空间地址，一个进程崩溃后，在**保护模式**下不会对其他进程产生影响，而线程只是一个进程中的不同执行路径。一个线程死掉回收堆空间往往会导致连锁反应让整个进程死掉。
- 3、体系现在通信机制上，正因为进程间互不干扰，相互独立，进程的通信机制相对复杂，譬如管道、信号、消息队列、共享内存、套接字等通信机制，而线程由于共享数据段所以通信机制很方便。

### 进程和线程的选取
- 需要频繁**创建和销毁**优先使用线程，因为进程的创建和销毁代价很大。
- 因为对CPU系统的多核利用上线程更加占优，所以多机分布用进程，多核分布用线程
- 需要更稳定和安全时，用进程；需要速度时用线程。

### 线程崩溃不一定会导致进程崩溃
崩溃一般是由**共享地址空间带来的连锁反应**，比如一个线程堆栈溢出崩溃了，然后线程结束需要回收堆资源，导致其它共享地址空间的线程**使用相应数据**又发生了堆栈溢出。

### 线程间的共享和私有数据
#### 共享数据：
- 文件描述符表
- 每种信号的处理方式（SIG_IGN、SIG_DFL或自定义的信号处理函数）
- 当前工作目录
- 用户id和组id
- 地址空间
#### 私有数据：
- 线程id
- **上下文信息，包括各种寄存器的值、程序计数器和栈指针**
- **栈空间**（临时变量存储在栈空间中）
- errno变量
- 信号屏蔽字
- 调度优先级

### 如何检查内存泄漏

### malloc大内存跟物理内存的关系

### 死锁成立的条件
- （1）互斥条件：一个资源只被一个进程占用
- （2）占有且等待：一个进程等待其他进程时，继续占有已分配的资源
- （3）不可抢占：不能强行抢占进程已占有的资源
- （4）循环等待：存在一个闭合的进程链，每个进程至少占有此链中下一个进程所需要的一个资源。
### 死锁检测和恢复
如果进程-资源分配图中没有环路，没有发生死锁 \
如果进程-资源分配图中有环路，可以分为两种情况：\
1、每种资源类中仅有一个资源，则系统发生了死锁，此时环路是系统发生死锁的充分必要条件，环路中进程是死锁进程。\
2、每种资源类中有多个资源，系统未必会发生死锁。\
**检测算法**：每种类型一个资源的死锁检测算法是通过检测有向图是否有环来实现，从一个节点出发进行深度优先搜索，对访问过的节点进行标记，如果访问过已经标记的节点，就表示有向图存在环，发生死锁\
**死锁恢复**：
  - 资源剥夺：剥夺陷于死锁的进程所占用的资源，但不撤销此进程直到接触死锁
  - 进程回退法：根据系统保存的检查点让所有进程回退，直到足以解除死锁，这种措施要求系统建立保存检查点、回退以及重启机制。
  - 进程撤销法：
    - 撤销陷入死锁的所有进程，解除死锁，继续运行
    - 逐个撤销陷入死锁的进程，回收其资源并重新分配，直至解除死锁。

### 死锁预防
- 互斥条件：不可避免
- 占有且等待：要求进城一次性请求所有需要的资源，并阻塞这个进程直到所有请求都满足。但是进程可能事先不知道它所需要的资源。
- 不可抢占：两种方式1、占有资源的进程去申请资源被拒绝时，必须释放最初占有的资源。2、任意两个进程优先级不同时，当一个进程请求另一个进程占用的资源时，操作系统可以**抢占**另一个，要求它释放资源
- 循环等待：定义资源类型的线性顺序来，若一个进程分配了R类型的资源，则接下来请求的只能是排在R类型之后的资源。但是会导致进程执行变慢。

### 死锁避免
死锁预防通过约束资源请求来至少破坏四个死锁条件中的一个，但会导致低效的资源使用和低效的进程执行。死锁避免**允许**三个必要条件（互斥、占有且等待、非抢占），但确保永远不会到达死锁点，**需要知道未来进程资源请求的情况**，两种避免方法：
- 若一个进程的请求会导致死锁，则不启动该进程
- 若一个进程增加的资源请求会导致死锁，则不允许这一资源分配

#### 资源拒绝分配（银行家算法）
**安全状态**指至少一个资源分配序列不会导致死锁（即所有进程都能运行直到结束），不安全状态指非安全的状态。顾客对应进程，钱对应资源，银行能贷出的钱有限，每个顾客都有一定的信用额（需要的总资源），顾客可以选择借一部分（申请部分资源），但不能保证顾客取得大量贷款后一定能偿还，银行家没有足够的本金时，拒绝贷款给顾客（拒绝资源）。\
例如ABCD分别已经拥有了1/1/2/4的资源，最大需求为6/5/4/7，银行家有空闲的2，通过依次满足CDBA的请求可实现需求。
#### 死锁避免优缺点
- 优点：不需要死锁预防中的抢占和回滚进程，且比预防的限制少
- 缺点：也有许多限制：
  - 必须事先声明每个进程请求的最大资源
  - 进程的**执行顺序必须没有任何同步要求限制**
  - 分配资源的数量必须固定
  - 占有资源时进程不能退出

### 互斥锁、递归锁、读写锁、自旋锁、RCU
- 互斥锁：需要访问互斥资源时，尝试获取锁，获取失败则睡眠，资源使用完之后解锁，然后环形睡眠进程
- 递归锁：同一线程可以多次获取一个锁资源，而当所有次数都被释放，其他线程才能获取该锁资源。一般来说需要用到递归锁的情况说明设计是有问题的，尽量避免使用递归锁。
- 读写锁：读写锁有三种状态（读状态加锁，写状态加锁，未加锁）。读状态锁可以由多个进程占有，写状态锁只能由一个进程占有且当前没有进程占有读状态锁。
- 自旋锁：当一个线程尝试获取某一锁资源失败时，它不会睡眠，而是忙等待该锁被其他线程释放。好处是效率高，少了睡眠唤醒的开销，缺点是占用CPU资源。
- RCU：read-copy-update，**读数据时不需要加锁**，需要修改数据时，**先拷贝一份**，然后等到实际合适的时候通过回调机制将修改后的数据写回原处。可以支持**一个写操作**和多个读操作同时进行。

### 内存模型
地址空间由低到高：.text代码段、.data数据段、.bss段、堆区、内存映射区、栈区、内核空间。

### 操作系统中的内存管理机制？
1. 块式管理 ： 远古时代的计算机操系统的内存管理⽅式。将内存分为⼏个固定⼤⼩的块，每个块中只包含⼀个进程。如果程序运⾏需要内存的话，操作系统就分配给它⼀块，如果程序运⾏只需要很⼩的空间的话，分配的这块内存很⼤⼀部分⼏乎被浪费了。这些在每个块中未被利⽤的空间，我们称之为**碎⽚**。
2. ⻚式管理 ：把主存分为⼤⼩相等且固定的⼀⻚⼀⻚的形式，⻚面尺寸⼩，相对相⽐于块式管理的划分⼒度更⼤，提⾼了内存利⽤率，减少了碎⽚。⻚式管理通过⻚表对应逻辑地址和物理地址。
3. 段式管理 ： ⻚式管理虽然提⾼了内存利⽤率，但是⻚式管理其中的⻚实际并⽆任何实际意义。
段式管理把主存分为⼀段段的，每⼀段的空间⼜要⽐⼀⻚的空间⼩很多 。但是，最重要的是段是有实际意义的，每个段定义了⼀组逻辑信息，例如,有主程序段 MAIN、⼦程序段 X、数据段 D及栈段 S 等。 段式管理通过段表对应逻辑地址和物理地址。
4. 段页式管理机制。段⻚式管理机制结合了段式管理和⻚式管理的优点。简单来说段⻚式管理机制就是把主存先分成若⼲段，每个段⼜分成若⼲⻚，也就是说 段⻚式管理机制 中段与段之间以及段的内部的都是离散的。

### 页表管理机制中有两个很重要的概念：快表和多级页表
在分页内存管理中，很重要的两个问题是：
1. 虚拟地址到物理地址的转换要快
2. 解决虚拟地址空间大，页表也会很大的问题
#### 快表（TLB Translation Lookaside Buffer）
为了解决虚拟地址到物理地址的转换速度，操作系统在 ⻚表⽅案 基础之上引⼊了 快表 来加速虚拟地址到物理地址的转换。我们可以把快表理解为⼀种特殊的⾼速缓冲存储器（Cache），其中的内容是⻚表的⼀部分或者全部内容。作为⻚表的 Cache，它的作⽤与⻚表相似，但是提⾼了访问速率。由于采⽤⻚表做地址转换，读写内存数据时 CPU 要访问两次主存。有了快表，有时只要访问⼀次⾼速缓冲存储器，⼀次主存，这样可加速查找并提⾼指令执⾏速度。\
使⽤快表之后的地址转换流程是这样的：
1. 根据虚拟地址中的⻚号查快表；
2. 如果该⻚在快表中，直接从快表中读取相应的物理地址；
3. 如果该⻚不在快表中，就访问内存中的⻚表，再从⻚表中得到物理地址，同时将⻚表中的该映射表项添加到快表中；
4. 当快表填满后，⼜要登记新⻚时，就按照⼀定的淘汰策略淘汰掉快表中的⼀个⻚。

#### 多级页表
引⼊多级⻚表的主要⽬的是为了避免把全部⻚表⼀直放在内存中占⽤过多空间，特别是那些根本就不需要的⻚表就不需要保留在内存中。

### 分页和分段的共同点和区别
- 共同点：
  1. 分页和分段都是为了提高内存利用率，减少内存碎片
  2. 页和段都是离散存储的，二者都是离散分配内存的方式，但是每个页和段中的内存是连续的。
- 区别：
  1. 页的大小是固定的，由操作系统决定，段的大小不固定，取决于我们运行的程序
  2. 分页仅仅是为了满足操作系统内存管理的需求，而段是逻辑信息的单位，在程序中体现为数据段、代码段，能够更好满足用户的需要

### CPU如何寻址？为什么需要虚拟地址空间？
现代处理器使⽤的是⼀种称为 虚拟寻址(Virtual Addressing) 的寻址⽅式。使⽤虚拟寻址，CPU 需要将虚拟地址翻译成物理地址，这样才能访问到真实的物理内存。 实际上完成虚拟地址转换为物理地址转换的硬件是 CPU 中含有⼀个被称为 内存管理单元（Memory Management Unit, MMU）的硬件。
![avatar](/img/xunzhi.png)
#### 为什么需要虚拟地址空间？
先从没有虚拟地址空间的时候说起吧！没有虚拟地址空间的时候，程序都是直接访问和操作的都是物理
内存 。但是这样有什么问题呢？
1. ⽤户程序可以访问任意内存，寻址内存的每个字节，这样就很容易（有意或者⽆意）破坏操作系统，造成操作系统崩溃。
2. 想要同时运⾏多个程序特别困难，⽐如你想同时运⾏⼀个微信和⼀个 QQ ⾳乐都不⾏。为什么呢？举个简单的例⼦：微信在运⾏的时候给内存地址 1xxx 赋值后，QQ ⾳乐也同样给内存地址1xxx 赋值，那么 QQ ⾳乐对内存的赋值就会覆盖微信之前所赋的值，这就造成了微信这个程序
就会崩溃。

总结来说：**如果直接把物理地址暴露出来的话会带来严重问题，⽐如可能对操作系统造成伤害以及给同时运⾏多个程序造成困难。**
通过虚拟地址访问内存有以下优势：
- 程序可以使⽤⼀系列相邻的虚拟地址来访问物理内存中不相邻的⼤内存缓冲区。
- 程序可以使⽤⼀系列虚拟地址来访问⼤于可⽤物理内存的内存缓冲区。当物理内存的供应量变⼩时，内存管理器会将物理内存⻚（通常⼤⼩为 4 KB）保存到磁盘⽂件。数据或代码⻚会根据需要在物理内存与磁盘之间移动。
- 不同进程使⽤的虚拟地址彼此隔离。⼀个进程中的代码⽆法更改正在由另⼀进程或操作系统使⽤的物理内存。

### 什么是虚拟内存？
核心思想：扩容和隔离\
虚拟内存是为了解决**程序占用内存超过物理内存的情况**，另外，虚拟内存为每个进程提供了⼀个**⼀致的、私有的**地址空间，它让每个进程产⽣了⼀种⾃⼰在独享主存的错觉（每个进程拥有⼀⽚连续完整的内存空间）。虚拟内存的重要意义是它定义了⼀个连续的虚拟地址空间，并且把内存扩展到硬盘空间。

### 什么是局部性原理？
局部性原理是虚拟内存技术的基础，正是因为程序运⾏具有局部性原理，才可以只装⼊部分程序到内存就开始运⾏。

局部性原理表现在以下两个⽅⾯：
1. 时间局部性 ：如果程序中的某条指令⼀旦执⾏，不久以后该指令可能再次执⾏；如果某数据被访问过，不久以后该数据可能再次被访问。产⽣时间局部性的典型原因，是由于在程序中存在着⼤量的循环操作。
2. 空间局部性 ：⼀旦程序访问了某个存储单元，在不久之后，其附近的存储单元也将被访问，即程序在⼀段时间内所访问的地址，可能集中在⼀定的范围之内，这是因为**指令通常是顺序存放、顺序执⾏的，数据也⼀般是以向量、数组、表等形式簇聚存储的。**

时间局部性是通过将近来使⽤的指令和数据保存到⾼速缓存存储器中，并使⽤⾼速缓存的层次结构实现。空间局部性通常是使⽤᫾⼤的⾼速缓存，并将预取机制集成到⾼速缓存控制逻辑中实现。虚拟内存技术实际上就是建⽴了 “内存⼀外存”的两级存储器的结构，利⽤局部性原理实现髙速缓存。

### 什么是虚拟存储器？
基于局部性原理，在程序装⼊时，可以将程序的⼀部分装⼊内存，⽽将其他部分留在外存，就可以启动程序执⾏。由于外存往往⽐内存⼤很多，所以我们运⾏的软件的内存⼤⼩实际上是可以⽐计算机系统实
际的内存⼤⼩⼤的。在程序执⾏过程中，当所访问的信息不在内存时，由操作系统将所需要的部分调⼊内存，然后继续执⾏程序。另⼀⽅⾯，操作系统将内存中暂时不使⽤的内容换到外存上，从⽽腾出空间
存放将要调⼊内存的信息。这样，计算机好像为⽤户提供了⼀个**⽐实际内存⼤的多的存储器**——虚拟存储器。\
实际上，我觉得虚拟内存同样是⼀种时间换空间的策略，你⽤ CPU 的计算时间，⻚的调⼊调出花费的时间，换来了⼀个虚拟的更⼤的空间来⽀持程序的运⾏。

### 虚拟内存技术如何实现的？

虚拟内存的实现需要建⽴在离散分配的内存管理⽅式的基础上。 虚拟内存的实现有以下三种⽅式：
1. 请求分⻚存储管理 ：建⽴在分⻚管理之上，为了⽀持虚拟存储器功能⽽增加了请求调⻚功能和⻚⾯置换功能。请求分⻚是⽬前最常⽤的⼀种实现虚拟存储器的⽅法。请求分⻚存储管理系统中，在作业开始运⾏之前，仅装⼊当前要执⾏的部分段即可运⾏。假如在作业运⾏的过程中发现要访问的⻚⾯不在内存，则由处理器通知操作系统按照对应的⻚⾯置换算法将相应的⻚⾯调⼊到
主存，同时操作系统也可以将暂时不⽤的⻚⾯置换到外存中。
2. 请求分段存储管理 ：建⽴在分段存储管理之上，增加了请求调段功能、分段置换功能。请求分段储存管理⽅式就如同请求分⻚储存管理⽅式⼀样，在作业开始运⾏之前，仅装⼊当前要执⾏的部分段即可运⾏；在执⾏过程中，可使⽤请求调⼊中断动态装⼊要访问但⼜不在内存的程序段；当内存空间已满，⽽⼜需要装⼊新的段时，根据置换功能适当调出某个段，以便腾出空间⽽装⼊新的段。
3. 请求段⻚式存储管理

#### 请求分⻚与分⻚存储管理，两者有何不同呢？
请求分⻚存储管理建⽴在分⻚管理之上。他们的根本区别是是否将程序全部所需的全部地址空间都装⼊
主存，这也是请求分⻚存储管理可以提供虚拟内存的原因，我们在上⾯已经分析过了。
它们之间的根本区别在于是否将⼀作业的全部地址空间同时装⼊主存。请求分⻚存储管理不要求将作业
全部地址空间同时装⼊主存。基于这⼀点，请求分⻚存储管理可以提供虚存，⽽分⻚存储管理却不能提
供虚存。\
不管是上⾯那种实现⽅式，我们⼀般都需要：
1. ⼀定容量的内存和外存：在载⼊程序的时候，只需要将程序的⼀部分装⼊内存，⽽将其他部分留
在外存，然后程序就可以执⾏了；
2. 缺⻚中断：如果需执⾏的指令或访问的数据尚未在内存（称为缺⻚或缺段），则由处理器通知操
作系统将相应的⻚⾯或段调⼊到内存，然后继续执⾏程序；
3. 虚拟地址空间 ：逻辑地址到物理地址的变换

### 常见的页面置换算法？
地址映射过程中，若在页面中发现所要访问的⻚⾯不在内存中，则发⽣缺⻚中断 。缺页中断就是要访问的⻚不在主存，需要操作系统将其调⼊主存后再进⾏访问。在这个时候，被内存映射的⽂件实际上成了⼀个分⻚交换⽂件。当发⽣缺⻚中断时，如果当前内存中并没有空闲的⻚⾯，操作系统就必须在内存选择⼀个⻚⾯将其移出内存，以便为即将调⼊的⻚⾯让出空间。⽤来选择淘汰哪⼀⻚的规则叫做⻚⾯置换算法，我们可以把⻚⾯置换算法看成是淘汰⻚⾯的规则。

- OPT ⻚⾯置换算法（最佳⻚⾯置换算法） ：最佳(Optimal, OPT)置换算法所选择的被淘汰⻚⾯将是以后永不使⽤的，或者是在最⻓时间内不再被访问的⻚⾯,这样可以保证获得最低的缺⻚率。但由于⼈们⽬前⽆法预知进程在内存下的若千⻚⾯中哪个是未来最⻓时间内不再被访问的，因⽽该算法⽆法实现。⼀般作为衡量其他置换算法的⽅法。
- FIFO（First In First Out） ⻚⾯置换算法（先进先出⻚⾯置换算法） : 总是淘汰最先进⼊内存的⻚⾯，即选择在内存中驻留时间最久的⻚⾯进⾏淘汰。
- LRU （Least Recently Used）⻚⾯置换算法（最近最久未使⽤⻚⾯置换算法） ：LRU算法赋予每个⻚⾯⼀个访问字段，⽤来记录⼀个⻚⾯⾃上次被访问以来所经历的时间 T，当须淘汰⼀个⻚⾯时，选择现有⻚⾯中其 T 值最⼤的，即最近最久未使⽤的⻚⾯予以淘汰。
- LFU （Least Frequently Used）⻚⾯置换算法（最少使⽤⻚⾯置换算法） : 该置换算法选择在之前时期使⽤最少的⻚⾯作为淘汰⻚。

### 线程切换时都有哪些内容？
### OS如何做到原子操作
### 线程上下文切换时，寄存器是否会保存全局变量
### 寄存器SP的作用
### MMU和TLB

### 五种IO模型
一个socket上的读操作包含两个阶段：
1. 等待数据准备好
2. 将数据从内核拷贝到用户进程中
- 阻塞IO（BIO）：在两个阶段都被阻塞了，阻塞等待数据、阻塞拷贝数据
- 非阻塞IO（NIO）:第一个阶段不阻塞，第二个阶段阻塞。对一个非阻塞socket读的时候，如果数据没准备好，会返回EWOULDBLOCK错误，如果准备好了就将数据拷贝到用户内存并返回。
- IO复用（事件驱动IO），单个线程里面同时监控多个socket，进程先是阻塞在select/poll上，再阻塞在第二个阶段。
- 信号驱动式IO：内核产生SIGIO信号，调用处理函数，就可以在处理函数中读数据。等待数据阶段不被阻塞，收到信号再阻塞拷贝数据
- 异步IO（AIO）:两个阶段都是内核完成，用户进程不会被阻塞。用户发起aio_read后系统调用立即返回，然后内核等待数据就绪，并自动拷贝到用户内存，整个过程完成后再给用户进程发信号，通知IO操作完成。
- AIO与信号驱动IO的区别是：信号驱动IO通知用户何时启动一个IO操作，异步IO内核通知用户IO操作何时完成。
- 同步IO与异步IO，阻塞、非阻塞、IO复用、信号驱动都是同步IO、只有异步IO模型是异步IO。同步IO操作导致进程阻塞，直到IO操作完成。异步IO操作不导致进程阻塞。

## 数据结构
### 哈希表、哈希冲突如何解决？
**定义**：理想的散列表是一个数组，存储的每一个关键字通过散列函数映射到数组的不同位置，散列函数应该尽可能均匀分配关键字，并设计当两个关键字散列大到同一个值的时候如何处理。\
**哈希冲突**：哈希冲突就是不同的key产生了相同的地址，STL使用的是**开链法**，数组可以实现查找容易，但插入和删除难，链表查找难，插入和删除难，所以可以用二者组合起来，链表足够短还是够快的。\
**线性探测**：如果碰到冲突直接放在后一个位置，但是会形成主集团，即会在某个位置形成聚集，可以用二次探测来解决，即如果碰到冲突就放在后面+i平方的位置，但是会形成次主集团。

### 红黑树
红黑树的性质：
- 每个节点要么黑色要么红色
-	根为黑色
- 所有叶子节点的子节点（空节点）是黑色的
-	红色节点的两个子节点必须是黑色
-	从一个节点到null的路径包含相同的**黑色**节点数

插入删除复杂度$O(logn)$

插入：规定新插入的元素为红色，自顶向下查找该元素的插入位置时，如果一个节点有两个红儿子，将三者颜色翻转，记得最后置根节点为黑色，如果该节点翻转后父节点为红色，应用单旋转或双旋转，这样找到元素插入位置时，如果父元素为黑色，插入完成，如果父元素为红色，那么叔叔元素一定为黑色，可以借助单旋转或双旋转解决问题。


## 题
### 两个线程循环打印1-100
用条件变量和锁来进行操作，一个标志位来切换线程
```C++
mutex mtx;
condition_variable cv;
int ready=0;
void worker1(){
    unique_lock<mutex> lk(mtx);//获取锁
    int n = 1;
    while(n<100){
        while(ready!=0)//防止虚假唤醒
            cv.wait(lk);//释放锁，挂起线程
        cout <<this_thread::get_id() << " "<< n << endl;
        n += 2;
        ready = 1;//通知下一个ready=1的线程启动
        cv.notify_all();//唤醒所有线程
    }
}
void worker2(){
    unique_lock<mutex> lk(mtx);
    int n = 2;
    while (n<=100)
    {
        while(ready!=1)
            cv.wait(lk);
        cout << this_thread::get_id()<<" "<<n << endl;
        n += 2;
        ready = 0;
        cv.notify_all();
    }  
}
```

### 实现智能指针
```C++
template <class T>
class sharedptr{
private:
    int *m_refCount;//引用计数
    T *m_pointer;//资源指针
public:
    sharedptr():m_refCount(nullptr),m_pointer(nullptr){}
    sharedptr(T *adoptTarget):m_refCount(nullptr),m_pointer(adoptTarget){
        addReference();
    }
    //拷贝构造
    sharedptr(const sharedptr<T>& copy):m_refCount(copy.m_refCount),m_pointer(copy.m_pointer){
        addReference();
    }
    virtual ~sharedptr(){//智能指针析构函数，将引用-1
        removeReference();
    }
    //赋值
    sharedptr<T>& operator=(const sharedptr<T>& that){//赋值操作
        if(this != &that){
            removeReference();
            this->m_pointer = that.m_pointer;
            this->m_refCount = that.m_refCount;
            addReference();
        }
        return *this;
    }
    //
    bool operator==(const sharedptr<T>& other){
        return m_pointer == other.m_pointer;
    }
    bool operator!=(const sharedptr<T>& other){
        return !operator==(other);
    }
    //
    T& operator*() const{//智能指针的解引用
        return *m_pointer;
    }
    T* operator->() const{
        return m_pointer;
    }
    int GetReferenceCount() const{
        if(m_refCount){
            return *m_refCount;
        }
        return -1;
    }
protected:
    void addReference(){
        cout << "addReference" << endl;
        if(m_refCount){//引用计数不为0
            (*m_refCount)++;
        }
        else{//引用计数为0
            m_refCount = new int(0);
            *m_refCount = 1;
        }
    }
    void removeReference(){
        cout << "removeReference" << endl;
        if(m_refCount){
            (*m_refCount)--;
            cout << "refCount: " << *m_refCount << endl;
            if(*m_refCount==0){//如果没有引用为0，直接调用类的析构函数和智能指针的析构函数
                cout << "refcount=0" << endl;
                delete m_refCount;
                delete m_pointer;//调用对象类的析构函数
                m_refCount = 0;
                m_pointer = 0;
            }
        }
    }
};
```
weak_ptr的实现，shared_ptr多了一个weakrefcnt
```C++
template <class T>
class weakptr{
public:
  T* m_pointer;
  weakptr(T* adoptTarget){
    m_pointer = adoptTarget;
  }
  //赋值运算符
  weakptr& operator=(sharedptr<T>& ptr){
    m_pointer = ptr.m_pointer;
    (*ptr.weakrefcnt)++;
  }
  ~weakptr(){
  }
};
```
### 手写单例模式
#### Meyer's Singleton
1. 仅当程序执行到GetInstance()函数时，执行instance对象的初始化。
2. C++11之后，被static修饰的变量可以保证是线程安全的。
3. 禁用拷贝构造、移动构造、赋值运算来防止唯一实例的拷贝或移动，不暴露构造和析构函数防止其他途径实例化，protected保证可以被子类继承使用。
```C++
template<class T>
class Singleton{
public:
    static T& GetInstance(){
      static T instance;
      return instance;
    }
    Singleton(T&&) = delete;
    Singleton(const T&) = delete;
    void operator=(const T&) = delete;
protected:
    Singleton() = default;
    virtual ~Singleton() = default;
};
```
#### 饿汉模式
在程序最开始就创建实例，不管后续是否用到
1. 在main函数执行初始化没有线程安全问题
2. 由于编译顺序不确定，如果在staic Singleton instance完成之前调用 static Singleton& getInstance()会返回一个未定义的实例
```C++
template<class T>
class Singleton{
private:
  static Singleton instance;
private:
  Singleton();
  ~Singleton();
  Singleton(T&&) = delete;
  Singleton(const T&) = delete;
  void operator=(const T&) = delete;
public:
  static Singleton& getInstance(){
    return instance;
  }
}
Singleton Singleton::instance;//默认初始化
```
#### 懒汉模式
只有在使用实例的时候才创建

```C++
class singleton{
private:
    singleton();
    singleton(const singleton& other);
public:
    static singleton* getinstance();
    static singleton* m_instance;
}
singleton* singleton::m_instance = nullptr;
//线程非安全版本
singleton* singleton::getinstance(){
    if(m_instance == nullptr){
        m_instance = new singleton();
    }
    return m_instance;
}
//由于多线程情况下可能会有多个线程同时执行判断，可能会创建多个对象
//线程安全版本，加锁
singleton* singleton::getinstance(){
    locker lock;
    if(m_instance == nullptr){
        m_instance = new singleton();
    }
    return m_instance;
}
//加锁之后只有一个线程可以获得锁，保证了多线程下的安全，但是代价过高，因为当一个线程获取了锁创建了对象之后，其他线程只是在进行读操作即只是执行return m_instance所以加锁是没有必要的，所以锁会造成资源浪费
//线程安全版本，双检查锁
singleton* singleton::getinstance(){
    if(m_instance == nullptr){
        locker lock;
        if(m_instance == nullptr){
            m_instance = new singleton();
        }        
    }
    return m_instance;
}
//如果是空，有线程进来获得锁，然后创建对象，锁后检查原因：其他线程如果有两个同时进来，如果没有检查if，那么会先后获得锁然后创建对象，如果有了后面的if就可以避免这种情况
//但是这种方法是不安全的，内存读写会有reorder，会导致双检查锁失效，`m_instance = new singleton()`正常情况下指令序列是：分配内存、调用构造函数（对分配的内存进行初始化）、返回值（把地址指针给m_instance），但是reoder之后可能是先分配内存然后返回值然后调用构造函数，这就会导致一个线程在调用构造器之前m_instance就不是null，而另一个线程进来之后会判断认为这是一个合法的对象而直接使用
//解决方法C++11使用atomic_thread_fence()来禁止reorder
std::aotmic<singleton*> singleton::m_instance;
std::mutex singleton::m_mutex;

singleton* singleton::getinstance(){
    singleton* tmp = m_instance.load(std::memory_order_relaxed);
    std::atomic_thread_fence(std::memory_order_acquire);
    if(tmp == nullptr){
        std::lock_guard<std::mutex> lock(m_mutex);
        tmp = m_instance.load(std::memory_order_relaxed);
        if(tmp == nullptr){
            tmp = new singleton();
            std::atomic_thread_fence(std::memory_order_release);
            m_instance.store(tmp, std::memory_order_relaxed);
        }        
    }
    return tmp;
}

```
