---
layout:     post
title:      "面试问题整理"
subtitle:   "整理中…"
date:       "2021-06-29"
author:     "Johann"
# # header-img: "img/post-bg-js-version.jpg"
tags:
    - 面试题
---
topK:最大的，用小根堆，大于堆顶就push，然后pop堆顶；最小的，用大根堆，小于堆顶就push，然后pop堆顶；
- [1、C++基础](#1c基础)
  - [static关键字](#static关键字)
  - [const在内存的哪里](#const在内存的哪里)
  - [int *const和const int *](#int-const和const-int-)
  - [成员函数后面加const](#成员函数后面加const)
  - [extern关键字](#extern关键字)
  - [restrict](#restrict)
  - [四种类型转换](#四种类型转换)
  - [隐式类型转换](#隐式类型转换)
  - [new/delete和malloc/free区别](#newdelete和mallocfree区别)
  - [C++类中可以定义应用数据成员吗？](#c类中可以定义应用数据成员吗)
  - [为什么用成员初始化列表会快一些](#为什么用成员初始化列表会快一些)
  - [多态和虚函数](#多态和虚函数)
  - [C实现多态](#c实现多态)
  - [析构函数为何必须是虚函数？C++默认的为何不是虚函数？](#析构函数为何必须是虚函数c默认的为何不是虚函数)
  - [重载、重写、隐藏](#重载重写隐藏)
  - [析构函数](#析构函数)
  - [析构函数可以是纯虚函数吗](#析构函数可以是纯虚函数吗)
  - [在main()函数之前执行的函数](#在main函数之前执行的函数)
  - [C语言函数调用流程](#c语言函数调用流程)
  - [C参数的压栈顺序](#c参数的压栈顺序)
  - [拷贝构造函数](#拷贝构造函数)
  - [C++中拷贝构造函数的形参能否进行值传递](#c中拷贝构造函数的形参能否进行值传递)
  - [do while(0)的目的](#do-while0的目的)
- [STL](#stl)
  - [STL组成部分](#stl组成部分)
  - [vector和list区别](#vector和list区别)
  - [map和set区别](#map和set区别)
  - [map的key如果是结构体需要重载<运算符](#map的key如果是结构体需要重载运算符)
  - [上千万数据的map如何释放内存](#上千万数据的map如何释放内存)
  - [STL的allocator](#stl的allocator)
  - [STL迭代器删除元素](#stl迭代器删除元素)
  - [迭代器的作用](#迭代器的作用)
  - [resize和reserve](#resize和reserve)
  - [编译](#编译)
  - [define与const区别](#define与const区别)
  - [堆栈区别](#堆栈区别)
  - [struct和class区别](#struct和class区别)
- [网络编程](#网络编程)
  - [Reactor模型](#reactor模型)
  - [TCP的connect函数](#tcp的connect函数)
  - [read和write](#read和write)
    - [read](#read)
    - [write](#write)
  - [TCP如何保证可靠性](#tcp如何保证可靠性)
  - [拥塞控制](#拥塞控制)
  - [拥塞发生时拥塞控制的行为](#拥塞发生时拥塞控制的行为)
    - [如何判断拥塞发生？](#如何判断拥塞发生)
  - [为啥不能是两次握手？](#为啥不能是两次握手)
  - [为啥不用四次？](#为啥不用四次)
  - [TCP三次握手初始序列号为什么不用固定值？](#tcp三次握手初始序列号为什么不用固定值)
  - [TCP的保活](#tcp的保活)
  - [TIME_WAIT作用](#time_wait作用)
  - [为啥是2MSL](#为啥是2msl)
  - [出现大量CLOSE_WAIT原因以及处理方法](#出现大量close_wait原因以及处理方法)
  - [IP和MAC地址作用](#ip和mac地址作用)
  - [IP层如何知道报文该给哪个应用程序，如何区分TCP还是UDP报文](#ip层如何知道报文该给哪个应用程序如何区分tcp还是udp报文)
## 1、C++基础
### static关键字
无论是全局静态变量还是局部静态变量，只要是**初始化**了的就在.data区，**未初始化**的就在.bss区。使用static的场景:
- （1）全局静态变量：全局变量前加static,作用域为其**所在的文件**，即它**对其他文件是不可见**的。
- （2）局部静态变量：在函数体中声明的静态变量，虽然**不会**随函数的结束而销毁，但是**作用域和函数体重其他变量是一样的**，在函数外不可见。下一次调用同样的函数时，其值会和上次保持一样。
- （3）静态函数：在函数名前面加上一个static即为静态函数，作用域为其所在的文件。
- （4）类中的静态**成员**：类中的静态成员需要在**类外初始化**，它不属于类的对象，而是属于类，所以使用它不需要this指针。
- （5）类中的静态成员函数：类中的静态函数也是属于整个类的，调用它也**不需要this指针**，所以函数体中也不能使用类的非静态成员（因为这个时候还没有对象，或者没有this指针不知道是哪个对象？）

### const在内存的哪里
被const修饰的是常量，不可修改，其约束的是编译器的行为，所以它在内存中的布局和普通变量一样在普通的变量区。
### int *const和const int *
**const在前**修饰的是解引用之后的内容，即**指针指向的对象**是const的；\
**const在后**修饰的是指针本身，即**指针地址**不可修改

### 成员函数后面加const
成员函数后面加const是**防止成员函数体内对成员对象进行修改**。与没有加const的函数属于**重载**，目的是让const对象调用const方法，非const对象调用非const方法。

### extern关键字
extern关键字表示其**修饰的变量或函数的定义在其源文件中**。
extern "C"表示接下来的内容按C语言的规则进行编译。比如C++编译器通过修改所有函数的名字来实现重载机制，C则是通过函数原本的名字来进行编译的。

### restrict
restrict,是C语言中的一种类型限定符（tpye qualifiers），用于告诉编译器，**对象已经被指针引用**，**不能**通过除该指针外所有其他之间或间接的方式来**修改该对象的内容**。

### 四种类型转换
- （1）reinterpret_cast：与C中的强制转换一样，没有任何限制
- （2）static_cast：用于各种隐式转换，用于void*与其他类型的指针之间的相互转换，**可用于多态父子类之间的转换但结果未知**
- （3）dynamic_cast：用于**父类指针**和**子类指针**，**父类引用和子类引用之间的转换**，若目标指针并非父类的子类，则会返回空，通过运行时类型推断实现的。
- （4）const_cast：用于将const类型转为非const类型。

### 隐式类型转换
没有显示类型转换的都是隐式转换，如①内置类型低精度的变量赋值给高精度的变量会发生隐式类型转换，②传给一个类的构造函数的变量若不是该类构造函数规定的参数类型的话也可能发生隐式类型转换。

### new/delete和malloc/free区别
- （1）new/delete是C++**关键字**，需要C++编译器支持。malloc/free是C**标准库函数**，需要包含相应头文件。
- （2）new分为两步，第一部分配内存，第二步调用构造函数；delete第一步调用析构函数，第二步释放内存。分配和释放内存底层使用malloc和free。
- （3）new返回的是**对象的指针**。malloc返回的是**void型指针**。
- （4）new失败后会抛出bad_alloc异常，并且可以使用set_new_handler设置new失败时的回调函数。malloc失败就返回空指针。

### C++类中可以定义应用数据成员吗？
可以，但必须使用初始化列表初始化

### 为什么用成员初始化列表会快一些
对于内置函数而言没有区别；对于用户定义的类而言，因为进入构造函数体后，所有对象都需要已经构造好，所以在之前会调用一次默认构造函数，然后在构造函数体内再调用一次特定的构造函数，这就会造成多调用了一次构造函数，损失效率。

### 多态和虚函数
多态就是同一个操作作用于不同的对象可以产生不同的效果，在C++中使用虚函数来实现多态。虚函数调用是一种只知道部分信息完成工作的机制，用户只需要知道接口而不需要知道具体对象，具体实现是依赖虚函数表，**有虚函数的类**中会有一个**指向虚函数表的指针**，当一个**派生类**自己实现了父类的虚函数后，会将该函数在**继承到的虚函数表**中的**地址改**写为其**重写**的虚函数的地址。

### C实现多态
仿照linux中虚拟文件系统的做法，结构体中有一个op对象，里面都是各种函数指针，不同的文件系统实现不同的函数，然后赋值给该函数指针。

### 析构函数为何必须是虚函数？C++默认的为何不是虚函数？
delete父类指针时必须要调用子类的析构函数。\
若默认析构函数是虚函数则每个类都需要引入虚函数表，没有必要。

### 重载、重写、隐藏
- 重载：函数名和返回值相同，参数列表不同
- 重写：不同层级的类中实现不同的虚函数
- 隐藏：不同层级的类中实现的同名函数

### 析构函数
一个对象生命周期结束的时候会调用它的析构函数，析构函数调用顺序：派生类析构函数->成员对象的析构函数->父类析构函数

### 析构函数可以是纯虚函数吗
可以。

### 在main()函数之前执行的函数
静态成员的构造函数

### C语言函数调用流程
将函数参数压栈\
将函数返回值压栈\
将栈帧指针（ebp寄存器值）压栈\
移动栈顶和栈帧指针，为函数创建一个新的栈帧。

### C参数的压栈顺序
从右往左，对于可边长参数，从左往右编译器难以确定明确的参数地址，而从右往左，最左的参数地址就是栈帧指针加上一个返回值的长度。

### 拷贝构造函数
用一个类对象初始化另一个类对象时；\
函数参数值传递时;\
返回值类型为对象时。

### C++中拷贝构造函数的形参能否进行值传递
不能，因为使用形参会调用拷贝构造函数，造成循环调用。

### do while(0)的目的
让代码不受分号，大括号的影响

## STL

### STL组成部分
容器、迭代器、分配器、算法、仿函数、配接器

### vector和list区别
都是线性容器，vector是顺序表支持随机访问，插入时间复杂度为O(n)，list是链表，只支持顺序访问，插入删除时间复杂度为O(1)。vector插入元素超过预留内存会向后继续扩张，并且每次扩张都是新建一个更大的vector然后把原来的复制过去，list不会。迭代器失效？

### map和set区别
map是键值对容器，map的迭代器key不可修改，value可修改；\
set是数据集合，迭代器不可修改。

### map的key如果是结构体需要重载<运算符

### 上千万数据的map如何释放内存
因为小于128byte的内存数据是用二级配置器申请的，使用完后会放回内存池，并没有真正释放，所以需要和临时空map对象swap后销毁临时swap对象。

### STL的allocator
是STL中广泛使用的对象配置器，提高了对象创建和销毁的效率。\
STL为了分工精细，使用配置器分配内存，使用construct和destroy函数处理对象的构造和析构。配置器分为两层，当所需内存大于128byte时嗲用二级配置器，其使用了内存池技术，以8byte为单位分了16种大小的槽位，每个槽位管理一个空闲链表，当空闲链表中没有空闲内存块时则从内存池中取一定数量的内存块放到空闲链表中。这里的空闲链表并没有多占用一点内存，其将next指针和内存块的头数据放在一个union中，避免了内存浪费。

### STL迭代器删除元素
STL使用erase删除迭代器内容。对于序列容器，erase返回所删除的迭代器的下一迭代器，但删除迭代器元素会导致后面迭代器均失效。对于关联容器，erase会导致被删除的迭代器失效，但是其它迭代器内容不失效，对于list来说，erase会返回下一迭代器，且其它迭代器均不失效。

### 迭代器的作用
迭代器的主要作用是将容器和算法分离，迭代器让容器的数据访问和遍历操作一致，这样算法使用迭代器对数据进行操作和遍历就不需要关心具体的容器类型，适用性更强。

### resize和reserve
resize改变的是size值，变小则后面的元素丢掉，变大则后面元素默认初始化。\
reserve改变的是容量，不增加元素。

### 编译

C++源文件到可执行文件的过程\
C++源文件->(预处理)->宏展开后的源文件->(编译阶段)->汇编文件->(汇编阶段)->可重定位的二进制文件->(链接阶段)->可执行文件

### define与const区别

- #define是宏定义，在预处理阶段会直接进行替换，全局有效，不做类型检查，没有作用域限制，可能会污染全局变量
- const是编译器处理的，有类型检查，有作用域限制，不会污染全局变量。但是由于宏替换的方式，使得编译过程变慢（预编译+编译），但程序运行变快，因为早就已经替换好了，直接运行就可以了，而const编译时间少，但是运行速度慢，因为要找内存空间去开辟变量。

### 堆栈区别

- 栈：存放的是函数的参数、局部变量、返回值地址。每次调用函数都会使用一个新的栈，存放函数的调用信息和返回类型，和临时变量。栈空间从高位向低位地址增长，一块连续的内存，最大容量是预定的。
- 堆：动态分配内存，由程序员申请分配和释放

### struct和class区别

- 默认继承访问权限。class默认是private，struct默认是public
- 默认访问权限。class作为**对象**的实现体，默认的成员变量访问控制是private。struct作为**数据结构**的实现体，默认的数据访问控制是public的。

## 网络编程
### Reactor模型
一般来说，reactor模型有三种角色，一个是accptor，一个是reactor，一个是handler。通过acceptor向reactor注册关注的事件，事件发生时，reactor将事件交给相应的handler处理执行相关的业务逻辑。**本质上是将关注的事件与相应回调函数关联，事件发生时执行相应的回调函数**\
与Proactor核心区别是Reactor处理的是**未完成IO的事件**，而Proactor处理的是已经完成IO的事件或信号。

### TCP的connect函数
TCP中的connect函数用于三次握手建立TCP连接。\
阻塞方法：发送SYN报文段，收到SYN、ACK报文段之后，发送ACK报文段然后返回。\
非阻塞方法：首先判断返回值，-1的话检查错误码，如果是ENTER，则重新connect，如果是EINPROGRESS，则说明正在连接中，其余错误码则说明连接出现错误。之后用epoll检查是否有写事件发生（accept检查读事件），如有写事件则用getsockopt检查错误，没有错误则连接成功。

### read和write
#### read
- 阻塞与非阻塞：\
阻塞的read在有数据时返回，没有数据时阻塞。非阻塞的read在没有数据时返回-1，错误码为EAGAIN或EWOULDBLOCK(其实也是EAGIN #define EWOULDBLOCK EAGAIN)
- 返回值：\
大于0->正常\
等于0->读到FIN，关闭连接；\
小于0->错误码为EINTR表示被信号中断，一般会重新调用read。错误码为EAGAIN表示当前没有数据。

#### write
- 阻塞与非阻塞：\
阻塞的write在缓冲区空间组已发送所有数据时才返回。\
非阻塞的wirte在缓冲区空间不够时只写一部分，然后返回写了的长度，之后再调用则返回-1，错误码EAGAIN或EWOULDBLOCK。
- 返回值：
大于0->正常\
等于0->套接字已经关闭\
小于0->错误码为EINTR表示被信号中断，一般会重新调用write，错误码为EAGAIN表示当前缓冲区没有空间。

### TCP如何保证可靠性
- （1）校验和：保证数据没有在传输中发生变化
- （2）序列号和确认号，超时重传：保证数据的送达
- （3）流量控制：保证接收方缓存足够接收数据
- （4）拥塞控制：保证数据发送不引起网络拥堵
- （5）三次握手四次挥手：保证连接和断开时的可靠

### 拥塞控制
- 慢启动：将拥塞窗口大小设定为1MSS（maximum segment size，发送者最大段大小），每个ACK到来就将拥塞窗口大小+1MSS。该状态**拥塞窗口呈指数增大**，每个RTT(round-trip time)增大一倍。慢启动的理由是**TCP刚开始发送数据时并不知道网络的实际情况，需要试探的方式平滑地增加拥塞窗口大小**，但是指数方式并不平滑，所以有**慢启动门限**，超过这个值会进入拥塞避免。

- 拥塞避免：拥塞避免使用CWND按照线性方式增加，从而减缓其扩大。

- 快恢复：实际是相对慢启动而言，拥塞窗口不是从1开始，而是从当前窗口的一半开始执行拥塞避免算法。

### 拥塞发生时拥塞控制的行为
#### 如何判断拥塞发生？
拥塞可能发生在慢启动或拥塞避免阶段。判断拥塞发生的依据：\
- 传输超时，或者说TCP重传定时器溢出。
- 接收到重复的ACK。\
对第一种情况仍然使用慢启动和拥塞避免，**但慢启动门限阈值设为之前的一半**，第二种情况使用快重传和快回复。如果第二种情况发生在**超时**之后也按第一种情况处理。

### 为啥不能是两次握手？
两次握手意味着服务端接收到**SYN报文段**之后即认为连接已经建立，并为其维护相关系统资源。但客户端发送SYN报文段之后可能由于网络**原因服务端**的SYN、ACK报文段并**没有送达客户端**，此时**客户端不认为**连接已经建立也不会发送数据，而**服务端将维护相关系统资源**一段比较长的时间，造成浪费。

### 为啥不用四次？
TCP是全双工通信，原本的握手模型确实应该像挥手一样进行四次，但是服务端回复ACK和发送SYN之间并没有联系，所以可以合并为一次发送，故握手只需要三次。

### TCP三次握手初始序列号为什么不用固定值？
防止串话，防止**上一个连接**的数据包在**本次连接建立后**才传来，并且在同一个窗口中

### TCP的保活
服务端每过一段时间（两小时）会发送一个心跳包（ACK报文段，序号为当前序号-1），正常情况下客户端回一个ACK，如果客户端异常掉线，则服务端每过一定时间（1000ms）发送一次心跳包，重复一定次数后关闭连接， 

### TIME_WAIT作用
- （1）可靠地终止TCP连接。实际上是确保最后一个ACK到达服务器，从而让服务器关闭连接。
- （2）保证让迟来的TCP报文段有足够的时间被识别并丢弃。报文段在网络中最大生存时间是MSL，等待2MSL是为了避免之前的连接的分组，进入新的连接中造成串话。

### 为啥是2MSL
保证客户端的最后一个ACK在一个MSL消逝之后，服务端超时重传的FIN报文段在1个MSL内发过来能被客户端接收到。

### 出现大量CLOSE_WAIT原因以及处理方法
CLOSE_WAIT出现在服务端收到FIN报文，但一直没有回送FIN报文的时候，一般是**因为服务器处于忙读等状态**，所以要处理好断开连接的情况，**在read返回值为0**或者**返回值小于0且errno不是EAGAIN**就断开连接（是被其他信号中断了？）。

### IP和MAC地址作用
MAC地址是硬件地址，由链路层负责，IP是网络层IP协议提供地址格式，是网络中每一个节点的逻辑地址，用以屏蔽硬件地址的差异。

### IP层如何知道报文该给哪个应用程序，如何区分TCP还是UDP报文
多路分解：IP数据报头部记录了协议标识，传输层报文头记录了目的端口号。