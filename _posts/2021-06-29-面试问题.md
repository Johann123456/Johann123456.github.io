---
layout:     post
title:      "面试问题整理"
subtitle:   "整理中…"
date:       "2021-06-29"
author:     "Johann"
# # header-img: "img/post-bg-js-version.jpg"
tags:
    - 面试题
---
- [1、C++基础](#1c基础)
  - [程序内存布局](#程序内存布局)
  - [为什么要内存对齐](#为什么要内存对齐)
  - [对齐的规则](#对齐的规则)
  - [如何让类只在堆/栈上创建对象](#如何让类只在堆栈上创建对象)
  - [C++类的内存布局](#c类的内存布局)
  - [指针和引用的区别](#指针和引用的区别)
  - [编译流程](#编译流程)
  - [智能指针](#智能指针)
  - [static关键字](#static关键字)
  - [const在内存的哪里](#const在内存的哪里)
  - [int *const和const int *](#int-const和const-int-)
  - [成员函数后面加const](#成员函数后面加const)
  - [extern关键字](#extern关键字)
  - [restrict](#restrict)
  - [四种类型转换](#四种类型转换)
  - [隐式类型转换](#隐式类型转换)
  - [new/delete和malloc/free区别](#newdelete和mallocfree区别)
  - [C++类中可以定义应用数据成员吗？](#c类中可以定义应用数据成员吗)
  - [为什么用成员初始化列表会快一些](#为什么用成员初始化列表会快一些)
  - [多态和虚函数](#多态和虚函数)
  - [C实现多态](#c实现多态)
  - [析构函数为何必须是虚函数？C++默认的为何不是虚函数？](#析构函数为何必须是虚函数c默认的为何不是虚函数)
  - [静态多态和动态多态](#静态多态和动态多态)
  - [重载、重写、隐藏](#重载重写隐藏)
  - [析构函数](#析构函数)
  - [析构函数可以是纯虚函数吗](#析构函数可以是纯虚函数吗)
  - [在main()函数之前执行的函数](#在main函数之前执行的函数)
  - [C语言函数调用流程](#c语言函数调用流程)
  - [C参数的压栈顺序](#c参数的压栈顺序)
  - [拷贝构造函数](#拷贝构造函数)
  - [C++中拷贝构造函数的形参能否进行值传递](#c中拷贝构造函数的形参能否进行值传递)
  - [do while(0)的目的](#do-while0的目的)
- [STL](#stl)
  - [STL组成部分](#stl组成部分)
  - [STL内存池](#stl内存池)
  - [vector和list区别](#vector和list区别)
  - [map和set区别](#map和set区别)
  - [map的key如果是结构体需要重载<运算符](#map的key如果是结构体需要重载运算符)
  - [上千万数据的map如何释放内存](#上千万数据的map如何释放内存)
  - [STL的allocator](#stl的allocator)
  - [STL迭代器删除元素](#stl迭代器删除元素)
  - [迭代器的作用](#迭代器的作用)
  - [迭代器失效](#迭代器失效)
  - [resize和reserve](#resize和reserve)
  - [编译](#编译)
  - [define与const区别](#define与const区别)
  - [堆栈区别](#堆栈区别)
  - [struct和class区别](#struct和class区别)
- [网络编程](#网络编程)
  - [Reactor模型](#reactor模型)
  - [TCP的connect函数](#tcp的connect函数)
  - [read和write](#read和write)
    - [read](#read)
    - [write](#write)
  - [HTTPS如何握手的](#https如何握手的)
  - [https可以被抓包吗？](#https可以被抓包吗)
  - [get和post区别](#get和post区别)
  - [TCP与UDP的区别](#tcp与udp的区别)
  - [TCP、UDP首部格式](#tcpudp首部格式)
  - [TCP如何保证可靠性](#tcp如何保证可靠性)
  - [TCP的粘包](#tcp的粘包)
  - [TCP滑动窗口](#tcp滑动窗口)
  - [拥塞控制](#拥塞控制)
  - [拥塞发生时拥塞控制的行为](#拥塞发生时拥塞控制的行为)
    - [如何判断拥塞发生？](#如何判断拥塞发生)
  - [为啥不能是两次握手？](#为啥不能是两次握手)
  - [为啥不用四次？](#为啥不用四次)
  - [TCP三次握手初始序列号为什么不用固定值？](#tcp三次握手初始序列号为什么不用固定值)
  - [TCP的保活](#tcp的保活)
  - [TIME_WAIT作用](#time_wait作用)
  - [为啥是2MSL](#为啥是2msl)
  - [出现大量CLOSE_WAIT原因以及处理方法](#出现大量close_wait原因以及处理方法)
  - [SYN洪范攻击](#syn洪范攻击)
  - [IP和MAC地址作用](#ip和mac地址作用)
  - [IP层如何知道报文该给哪个应用程序，如何区分TCP还是UDP报文](#ip层如何知道报文该给哪个应用程序如何区分tcp还是udp报文)
  - [https与http](#https与http)
- [操作系统](#操作系统)
  - [用户态和内核态](#用户态和内核态)
  - [用户态和内核态的切换](#用户态和内核态的切换)
  - [中断分类](#中断分类)
  - [并行和并发](#并行和并发)
  - [为什么要并发？](#为什么要并发)
  - [系统调用](#系统调用)
  - [进程和线程的区别](#进程和线程的区别)
  - [进程和线程的选取](#进程和线程的选取)
  - [线程崩溃不一定会导致进程崩溃](#线程崩溃不一定会导致进程崩溃)
  - [线程间的共享和私有数据](#线程间的共享和私有数据)
    - [共享数据：](#共享数据)
    - [私有数据：](#私有数据)
  - [系统调用的流程](#系统调用的流程)
  - [如何检查内存泄漏](#如何检查内存泄漏)
  - [进程的状态转移](#进程的状态转移)
  - [malloc大内存跟物理内存的关系](#malloc大内存跟物理内存的关系)
  - [虚拟内存](#虚拟内存)
  - [死锁成立的条件](#死锁成立的条件)
  - [死锁检测和恢复](#死锁检测和恢复)
  - [死锁预防](#死锁预防)
  - [死锁避免](#死锁避免)
    - [资源拒绝分配（银行家算法）](#资源拒绝分配银行家算法)
    - [死锁避免优缺点](#死锁避免优缺点)
  - [互斥锁、递归锁、读写锁、自旋锁、RCU](#互斥锁递归锁读写锁自旋锁rcu)
  - [内存模型](#内存模型)
  - [页式管理、段式管理、段页式](#页式管理段式管理段页式)
- [数据结构](#数据结构)
  - [哈希表、哈希冲突如何解决？](#哈希表哈希冲突如何解决)
  - [两个线程循环打印1-100](#两个线程循环打印1-100)
## 1、C++基础
### 程序内存布局
- 栈区：由编译器自动分配释放，存储函数的参数值，局部变量等
  - const局部变量存储在栈区，栈区向地址减小的方向增长。
- 堆区：由程序员申请和释放，分配方式类似于链表
  - 增长方向与内存地址增长方向相同，是不连续的区域，使用链表存储空闲节点
- 全局/静态区：全局变量和静态变量存储在一起的，在程序编译时分配
- 文字常量区：存储常量字符串
- 程序代码区：存储函数体（类的成员函数、全局函数）的二进制代码

### 为什么要内存对齐
CPU读取内存是按照chunk来进行的，如果一块内存大小是1字节，则所有内存都是对齐的，如果是4字节，如果没有内存对齐则一个4字节的数据可能要读多次。比如一个长度为4的数据从地址1开始存，CPU读取的粒度是4，则要读1234和5678内存的数据，然后再剔除合并，效率很低，如果是对齐的就可以一次就读出。

### 对齐的规则
```C++
struct test{
  int a;//从offset0开始4字节
  double b;//从8字节的整数倍开始8-15
  char c;//1字节整数倍还是1，所以是16+1=17字节，但不是8的整数倍，所以要补齐为24
};
struct test1{
  int a;//4字节
  test b;//最大元素为double b,所以从8的整数倍开始存8-31，
  double c;//8字节，32~39
  char d[100];//数组是分开存的，所以只取一个元素，40，但不是最大元素test b的整数倍，所以要补齐为48
};
```

### 如何让类只在堆/栈上创建对象
在栈上创建 `A a;`，在堆上创建`A* a = new A;`

### C++类的内存布局
- 数据和函数分开存放，函数放在代码区，数据放在堆区、栈区、静态/全局区、文字常量区，实例化不同对象时，只给数据分配空间，各个对象调用函数时都跳转到函数在代码区的入口执行，可以节省拷贝多份代码的空间。
- 类的静态成员变量分配到静态/全局区，因此静态成员变量属于类，所有对象公用一份，不计入类的内存空间。static变量存在静态/全局区。
- 静态成员函数和非静态成员函数都放在代码区，都属于类，类可以直接调用静态成员函数，不可以直接调用非静态成员函数
- 内联函数也放在代码区，内联函数在被调用时，

### 指针和引用的区别
- 引用是变量的别名，底层实现是常量指针int *const，即指针不可修改，一旦指向某处就不能再指向别处
- 引用在定义的同时必须初始化，应用不能为空，指针可以为空
- 引用使用时无需解引用，指针需要

### 编译流程
- 预处理：将所有的#include和宏定义替换成其真正的内容，预处理之后得到的仍是**文本文件**（.i文件）
- 编译：将经过预处理之后的程序转换成特定**汇编代码**（.s文件）
- 汇编：将汇编代码转换成机器码，生成的是**可重定位的二进制文件**（.obj文件）
- 链接：将多个目标文件以及所需的库文件（.so等）链接成最终可执行文件
一个进程的虚拟地址空间，如下所示:\
ZONE_DMA：直接内存访问，占用16M，用于磁盘与内存的文件进行数据交换
![avatar](/img/bainyi.jpg)
- .bss文件为什么不能运行
因为缺少program header，操作系统不知道从哪去load程序
![avatar](/img/loadprogram.jpg)
### 智能指针

### static关键字
无论是全局静态变量还是局部静态变量，只要是**初始化**了的就在.data区，**未初始化**的就在.bss区。使用static的场景:
- （1）全局静态变量：全局变量前加static,作用域为其**所在的文件**，即它**对其他文件是不可见**的。
- （2）局部静态变量：在函数体中声明的静态变量，虽然**不会**随函数的结束而销毁，但是**作用域和函数体中其他变量是一样的**，在函数外不可见。下一次调用同样的函数时，其值会和上次保持一样。
- （3）静态函数：在函数名前面加上一个static即为静态函数，作用域为其所在的文件。
- （4）类中的静态**成员**：类中的静态成员需要在**类外初始化**，它不属于类的对象，而是属于类，所以使用它不需要this指针。
- （5）类中的静态成员函数：类中的静态函数也是属于整个类的，调用它也**不需要this指针**，所以静态函数体中也不能使用类的非静态成员（因为这个时候还没有对象，或者没有this指针不知道是哪个对象？）

### const在内存的哪里
被const修饰的是常量，不可修改，其约束的是编译器的行为，所以它在内存中的布局和普通变量一样在普通的变量区。

### int *const和const int *
**const在前**修饰的是解引用之后的内容，即**指针指向的对象**是const的；\
**const在后**修饰的是指针本身，即**指针地址**不可修改

### 成员函数后面加const
成员函数后面加const是**防止成员函数体内对成员对象进行修改**。与没有加const的函数属于**重载**，目的是让const对象调用const方法，非const对象调用非const方法。

### extern关键字
extern关键字表示其**修饰的变量或函数的定义在其源文件中**。
extern "C"表示接下来的内容按C语言的规则进行编译。比如C++编译器通过修改所有函数的名字来实现重载机制，C则是通过函数原本的名字来进行编译的。

### restrict
restrict,是C语言中的一种类型限定符（tpye qualifiers），用于告诉编译器，**对象已经被指针引用**，**不能**通过除该指针外所有其他之间或间接的方式来**修改该对象的内容**。

### 四种类型转换
- （1）reinterpret_cast：与C中的强制转换一样，没有任何限制
- （2）static_cast：用于各种隐式转换，用于void*与其他类型的指针之间的相互转换，**可用于多态父子类之间的转换但结果未知**
- （3）dynamic_cast：用于**父类指针**和**子类指针**，**父类引用和子类引用之间的转换**，若目标指针并非父类的子类，则会返回空，通过运行时类型推断实现的。
- （4）const_cast：用于将const类型转为非const类型。

### 隐式类型转换
没有显示类型转换的都是隐式转换，如①内置类型低精度的变量赋值给高精度的变量会发生隐式类型转换，②传给一个类的构造函数的变量若不是该类构造函数规定的参数类型的话也可能发生隐式类型转换。

### new/delete和malloc/free区别
- （1）new/delete是C++**关键字**，需要C++编译器支持。malloc/free是C**标准库函数**，需要包含相应头文件。
- （2）new分为两步，第一部分配内存，第二步调用构造函数；delete第一步调用析构函数，第二步释放内存。分配和释放内存底层使用malloc和free。
- （3）new返回的是**对象的指针**。malloc返回的是**void型指针**。
- （4）new失败后会抛出bad_alloc异常，并且可以使用set_new_handler设置new失败时的回调函数。malloc失败就返回空指针。

### C++类中可以定义应用数据成员吗？
可以，但必须使用初始化列表初始化

### 为什么用成员初始化列表会快一些
对于内置函数而言没有区别；对于用户定义的类而言，因为进入构造函数体后，所有对象都需要已经构造好，所以在之前会调用一次默认构造函数，然后在构造函数体内再调用一次特定的构造函数，这就会造成多调用了一次构造函数，损失效率。

### 多态和虚函数
多态就是同一个操作作用于不同的对象可以产生不同的效果，在C++中使用虚函数来实现多态。虚函数调用是一种只知道部分信息完成工作的机制，用户只需要知道接口而不需要知道具体对象，具体实现是依赖虚函数表，**有虚函数的类**中会有一个**指向虚函数表的指针**，当一个**派生类**自己实现了父类的虚函数后，会将该函数在**继承到的虚函数表**中的**地址改**写为其**重写**的虚函数的地址。

### C实现多态
仿照linux中虚拟文件系统的做法，结构体中有一个op对象，里面都是各种函数指针，不同的文件系统实现不同的函数，然后赋值给该函数指针。

### 析构函数为何必须是虚函数？C++默认的为何不是虚函数？
delete父类指针时必须要调用子类的析构函数。通过基类指针销毁对象时，如果析构函数不是虚函数就不能正确识别对象类型，从而不能正确销毁对象，可能带来内存泄漏\
若默认析构函数是虚函数则每个类都需要引入虚函数表，没有必要。

### 静态多态和动态多态
**静态多态**通过**重载**和**模板**技术实现，在**编译的时候确定**。**动态多态**通过虚函数和继承关系实现，执行动态绑定，在**运行的时候确定**。

### 重载、重写、隐藏
- 重载：函数名和返回值相同，参数列表不同
- 重写：不同层级的类中实现不同的虚函数
- 隐藏：不同层级的类中实现的同名函数

### 析构函数
一个对象生命周期结束的时候会调用它的析构函数，析构函数调用顺序：派生类析构函数->成员对象的析构函数->父类析构函数

### 析构函数可以是纯虚函数吗
可以。

### 在main()函数之前执行的函数
静态成员的构造函数

### C语言函数调用流程
将函数参数压栈\
将函数返回值压栈\
将栈帧指针（ebp寄存器值）压栈\
移动栈顶和栈帧指针，为函数创建一个新的栈帧。

### C参数的压栈顺序
从右往左，对于可边长参数，从左往右编译器难以确定明确的参数地址，而从右往左，最左的参数地址就是栈帧指针加上一个返回值的长度。

### 拷贝构造函数
用一个类对象初始化另一个类对象时；\
函数参数值传递时;\
返回值类型为对象时。

### C++中拷贝构造函数的形参能否进行值传递
不能，因为使用形参会调用拷贝构造函数，造成循环调用。

### do while(0)的目的
让代码不受分号，大括号的影响

## STL

### STL组成部分
容器、迭代器、分配器、算法、仿函数、配接器

### STL内存池


### vector和list区别
都是线性容器，vector是顺序表支持随机访问，插入时间复杂度为O(n)，list是链表，只支持顺序访问，插入删除时间复杂度为O(1)。vector插入元素**超过预留内存**会向后继续扩张，并且每次扩张都是新建一个更大的vector然后把原来的复制过去，list不会。迭代器失效？

### map和set区别
map是键值对容器，map的迭代器key不可修改，value可修改；\
set是数据集合，迭代器不可修改。

### map的key如果是结构体需要重载<运算符

### 上千万数据的map如何释放内存
因为小于128byte的内存数据是用二级配置器申请的，使用完后会放回内存池，并没有真正释放，所以需要和临时空map对象swap后销毁临时map对象。

### STL的allocator
是STL中广泛使用的对象配置器，提高了对象创建和销毁的效率。\
STL为了分工精细，使用配置器分配内存，使用construct和destroy函数处理对象的构造和析构。配置器分为两层，当所需内存小于128byte时调用二级配置器，其使用了内存池技术，以8byte为单位分了16种大小的槽位，每个槽位管理一个空闲链表，当空闲链表中没有空闲内存块时则从内存池中取一定数量的内存块放到空闲链表中。这里的空闲链表并没有多占用一点内存，其将next指针和内存块的头数据放在一个union中，避免了内存浪费。

### STL迭代器删除元素
STL使用erase删除迭代器内容。对于序列容器（vector、deque），erase返回所删除的迭代器的下一迭代器，但删除迭代器元素会导致后面迭代器均失效。对于关联容器，erase会导致被删除的迭代器失效，但是其它迭代器内容不失效，对于list来说，erase会返回下一迭代器，且其它迭代器均不失效。

### 迭代器的作用
迭代器的主要作用是将容器和算法分离，迭代器让容器的数据访问和遍历操作一致，这样算法使用迭代器对数据进行操作和遍历就不需要关心具体的容器类型，适用性更强。

### 迭代器失效

迭代器失效分三种情况考虑，也是分三种数据结构考虑，分别为数组型，链表型，树型数据结构。

数组型数据结构：该数据结构的元素是分配在连续的内存中，insert和erase操作，都会使得删除点和插入点之后的元素挪位置，所以插入点和删除掉之后的迭代器全部失效，也就是说insert(*iter)(或erase(*iter))，然后在iter++，是没有意义的。解决方法：erase(*iter)的返回值是下一个有效迭代器的值。 iter =cont.erase(iter);

链表型数据结构：对于list型的数据结构，使用了不连续分配的内存，删除运算使指向删除位置的迭代器失效，但是不会失效其他迭代器.解决办法两种，erase(*iter)会返回下一个有效迭代器的值，或者erase(iter++).

树形数据结构：使用红黑树来存储数据，插入不会使得任何迭代器失效；删除运算使指向删除位置的迭代器失效，但是不会失效其他迭代器。erase迭代器只是被删元素的迭代器失效，但是返回值为void，所以要采用erase(iter++)的方式删除迭代器。

### resize和reserve
resize改变的是size值，变小则后面的元素丢掉，变大则后面元素默认初始化。\
reserve改变的是容量，不增加元素。

### 编译

C++源文件到可执行文件的过程\
C++源文件->(预处理)->宏展开后的源文件->(编译阶段)->汇编文件->(汇编阶段)->可重定位的二进制文件->(链接阶段)->可执行文件

### define与const区别

- #define是宏定义，在预处理阶段会直接进行替换，全局有效，不做类型检查，没有作用域限制，可能会污染全局变量
- const是编译器处理的，有类型检查，有作用域限制，不会污染全局变量。但是由于宏替换的方式，使得编译过程变慢（预编译+编译），但程序运行变快，因为早就已经替换好了，直接运行就可以了，而const编译时间少，但是运行速度慢，因为要找内存空间去开辟变量。
- #define可以定义表达式，const不能

### 堆栈区别

- 栈：存放的是函数的参数、局部变量、返回值地址。每次调用函数都会使用一个新的栈，存放函数的调用信息和返回类型，和临时变量。栈空间从高位向低位地址增长，一块连续的内存，最大容量是预定的。
- 堆：动态分配内存，由程序员申请分配和释放

### struct和class区别

- 默认继承访问权限。class默认是private，struct默认是public
- 默认访问权限。class作为**对象**的实现体，默认的成员变量访问控制是private。struct作为**数据结构**的实现体，默认的数据访问控制是public的。

## 网络编程
### Reactor模型
一般来说，reactor模型有三种角色，一个是accptor，一个是reactor，一个是handler。通过acceptor向reactor注册关注的事件，事件发生时，reactor将事件交给相应的handler处理执行相关的业务逻辑。**本质上是将关注的事件与相应回调函数关联，事件发生时执行相应的回调函数**\
与Proactor核心区别是Reactor处理的是**未完成IO的事件**，而Proactor处理的是已经完成IO的事件或信号。

### TCP的connect函数
TCP中的connect函数用于三次握手建立TCP连接。\
阻塞方法：发送SYN报文段，收到SYN、ACK报文段之后，发送ACK报文段然后返回。\
非阻塞方法：首先判断返回值，-1的话检查错误码，如果是ENTER，则重新connect，如果是EINPROGRESS，则说明正在连接中，其余错误码则说明连接出现错误。之后用epoll检查是否有写事件发生（accept检查读事件），如有写事件则用getsockopt检查错误，没有错误则连接成功。

### read和write
#### read
- 阻塞与非阻塞：\
阻塞的read在有数据时返回，没有数据时阻塞。非阻塞的read在没有数据时返回-1，错误码为EAGAIN或EWOULDBLOCK(其实也是EAGIN #define EWOULDBLOCK EAGAIN)
- 返回值：\
大于0->正常\
等于0->读到FIN，关闭连接；\
小于0->错误码为EINTR表示被信号中断，一般会重新调用read。错误码为EAGAIN表示当前没有数据。

#### write
- 阻塞与非阻塞：\
阻塞的write在缓冲区空间组已发送所有数据时才返回。\
非阻塞的wirte在缓冲区空间不够时只写一部分，然后返回写了的长度，之后再调用则返回-1，错误码EAGAIN或EWOULDBLOCK。
- 返回值：
大于0->正常\
等于0->套接字已经关闭\
小于0->错误码为EINTR表示被信号中断，一般会重新调用write，错误码为EAGAIN表示当前缓冲区没有空间。
### HTTPS如何握手的
- 1、客户端发起https请求
- 2、服务器响应客户端，并把CA签发的服务器证书，这个证书包括**用CA私钥对服务器公钥加密后的密文和对服务器公钥的hash后的摘要**发给客户端
- 3、客户端验证公钥有效性（客户端拿到服务器发来的证书，从本地的CA根整数中获取CA公钥，对服务器证书的密文进行解密，获取服务器公钥，并对次进行一次hash，比较得到的结果与证书携带的是否一致，为了防止公钥被篡改）
- 4、验证有效之后客户端会生成一个会话密钥，用服务器的公钥对这个会话密钥进行加密，然后发给服务器
- 5、客户端收到后用私钥解密，获取会话密钥
- 6、客户端与服务器通过会话密钥进行对称加密通信
![avatar](/img/https.jpg)
- 总结：用对称加密进行通信，用非对称加密传输对称加密的密钥，数字证书保证非对称加密的公钥是可信的，用hash来保证服务器公钥没有被篡改。

### https可以被抓包吗？
会被抓包，https只是防止用户在不知情的情况下通信被监听，但如果用户主动授信，是可以构建中间人网络的，代理软件可以对传输内容进行解密。

### get和post区别
- 都包含请求头请求行，post多了请求body。
- get多用来查询，请求参数放在url中，不会对服务器上的内容产生作用。
- post用来提交，如把账号密码放入body中。
- GET是直接添加到URL后面的，直接就可以在URL中看到内容，而POST是放在报文内部的，用户无法直接看到。
- GET提交的数据长度是有限制的，因为URL长度有限制，具体的长度限制视浏览器而定。而POST没有。

作者：程序员吾非同
链接：https://zhuanlan.zhihu.com/p/72616216
来源：知乎
著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。


### TCP与UDP的区别
- TCP(Transmission Control Protocol，传输控制协议)：是面向连接的，提供可靠交付，有流量控制，拥塞控制，提供全双工通信，面向字节流（把应用层传下来的报文看成字节流，把字节流组织成大小不等的数据块），每一条TCP连接只能是点对点的（一对一）。
- UDP(User Datagram Protocol，用户数据报协议)：是无连接的，尽最大可能交付，没有拥塞控制，面向报文（对于应用程序传下来的报文不合并也不拆分，只是添加UDP首部），支持一对一、一对多、多对一和多对多的交互通信。

### TCP、UDP首部格式
- 首部格式UDP首部只有8字节包括源端口、目的端口、长度、校验和
- TCP首部有20字节固定首部
### TCP如何保证可靠性
- （1）校验和：保证数据没有在传输中发生变化
- （2）序列号(seq)和确认号(ack)机制，超时重传：保证数据的送达
- （3）流量控制：保证接收方缓存足够接收数据
- （4）拥塞控制：保证数据发送不引起网络拥堵
- （5）三次握手四次挥手：保证连接和断开时的可靠

### TCP的粘包
- 定义：发送方的若干包数据到接收方接收时粘成一包，从接收缓冲区看就是后一包数据的头紧跟着前一包数据的尾。UDP是不会发生粘包的，粘包问题在数据链路层、网络层、传输层都可能发生，UDP是基于报文发送的，UDP首部用了16bit来指示UDP数据报文的程度，因此有数据边界不会粘包。但是TCP是面向数据流的，**首部没有表示数据长度的字段**，所以会粘包。
- 粘包发生的场景：TCP是面向字节流的，没有边界，但是操作系统在**发送**TCP数据时会用缓冲区进行优化，如果一次请求发送的数据量较小，没到缓冲区大小，TCP会将多个请求合并为一个请求进行发送，这就形成了粘包。或者**接收端**没有及时处理缓存中的数据
- 解决方案：
  - 发送端固定包长度，如100字节，不足的补充0
  - 发送端每个包末尾使用固定的分隔符，如\r\n。如果发生拆包需要等待多个包都发过来之后找到\r\n再合并；例如FTP协议
  - 将消息分为头部和消息体，头部保存长度，只有读取到足够长度的消息之后才算是读取到了一个完整的消息。

### TCP滑动窗口

如果为每个数据包都确认一次，包的往返时间越长，网络吞吐量会越低。滑动窗口是指**无需等待确认应答就可以继续发送数据的最大值**。如果有ack丢失，可以通过下一个确认应答进行确认，这个模式叫累积确认，即每次确认的都是这个确认号之前所有的数据。\
如果发送窗口内左端的字节**已经发送并收到确认**则右移窗口直到左端第一个字节**不是**已发送且确认状态。\
接收窗口只对窗口内最后一个**按序到达**的字节进行确认，例如收到{31,34,35}则只对31去人，**发送方**得到第一个字节被确认之后就认为之前的所有字节都被接收了。
![avatar](/img/滑动窗口.jpg)


### 拥塞控制
- 慢启动：将拥塞窗口大小设定为1MSS（maximum segment size，发送者最大段大小），每个ACK到来就将拥塞窗口大小+1MSS。该状态**拥塞窗口呈指数增大**，每个RTT(round-trip time)增大一倍。慢启动的理由是**TCP刚开始发送数据时并不知道网络的实际情况，需要试探的方式平滑地增加拥塞窗口大小**，但是指数方式并不平滑，所以有**慢启动门限**，超过这个值会进入拥塞避免。

- 拥塞避免：拥塞避免使用CWND按照线性方式增加，从而减缓其扩大。

- 快恢复：实际是相对慢启动而言，拥塞窗口不是从1开始，而是从当前窗口的一半开始执行拥塞避免算法。

### 拥塞发生时拥塞控制的行为
#### 如何判断拥塞发生？
拥塞可能发生在慢启动或拥塞避免阶段。判断拥塞发生的依据
- 传输超时，或者说TCP重传定时器溢出。
- 接收到重复的ACK。\
对第一种情况仍然使用慢启动和拥塞避免，**但慢启动门限阈值设为之前的一半**，第二种情况使用快重传和快回复。如果第二种情况发生在**超时**之后也按第一种情况处理。

### 为啥不能是两次握手？
两次握手意味着服务端接收到**SYN报文段**之后即认为连接已经建立，并为其维护相关系统资源。但客户端发送SYN报文段之后可能由于网络**原因服务端**的SYN、ACK报文段并**没有送达客户端**，此时**客户端不认为**连接已经建立也不会发送数据，而**服务端将维护相关系统资源**一段比较长的时间，造成浪费。

### 为啥不用四次？
TCP是全双工通信，原本的握手模型确实应该像挥手一样进行四次，但是服务端回复ACK和发送SYN之间并没有联系，所以可以合并为一次发送，故握手只需要三次。

### TCP三次握手初始序列号为什么不用固定值？
防止串话，防止**上一个连接**的数据包在**本次连接建立后**才传来，并且在同一个窗口中

### TCP的保活
服务端每过一段时间（两小时）会发送一个心跳包（ACK报文段，序号为当前序号-1），正常情况下客户端回一个ACK，如果客户端异常掉线，则服务端每过一定时间（1000ms）发送一次心跳包，重复一定次数后关闭连接， 

### TIME_WAIT作用
- （1）可靠地终止TCP连接。实际上是**确保最后一个ACK到达服务器，从而让服务器关闭连接**。
- （2）**保证让迟来的TCP报文段有足够的时间被识别并丢弃**。报文段在网络中最大生存时间是MSL，等待2MSL是为了避免之前的连接的分组，进入新的连接中造成串话。

### 为啥是2MSL
- 保证客户端的最后一个ACK在一个MSL消逝之后，服务端超时重传的FIN报文段在1个MSL内发过来能被客户端接收到。
- 防止已失效的报文出现在新的连接中。

### 出现大量CLOSE_WAIT原因以及处理方法
CLOSE_WAIT出现在服务端收到FIN报文，但一直没有回送FIN报文的时候，一般是**因为服务器处于忙读等状态**，所以要处理好断开连接的情况，**在read返回值为0**或者**返回值小于0且errno不是EAGAIN**就断开连接（是被其他信号中断了？）。

### SYN洪范攻击
攻击者发送大量的SYN报文段，而不完成第三次握手，随着SYN报文段到来，服务器会不断为这些半开连接分配资源，导致服务器资源耗尽。\
防御手段：SYN cookie服务器收到一个SYN报文段时，服务器不会为该报文段生成一个半开连接，相反，服务器会生成一个初始TCP序列号，该序列号是**SYN报文段**的**源**和**目的**IP地址与端口号通过**只有服务器知道**的哈希函数计算得到。重要的是，服务器并**不记忆该cookie或者任何应于SYN的其他状态信息**（三次握手的时候是分配了缓存和变量，即记录了状态信息）\
如果客户是合法的，那么客户会返回一个ACK，服务器收到ACK之后需要验证该ACK是否与前面发送的某些SYN对应（三次握手不需要验证因为分配了缓存和变量）。具体做法是将ACK报文段中的源和目的地IP地址与端口号执行同样的哈希函数，如果结果+1与SYNACK报文段中的确认号相同，则认为该ACK对应前面的SYN，是合法的，生成一个具有套接字的全开连接。
![avatar](/img/synattack.jpg)
### IP和MAC地址作用
MAC地址是硬件地址，由链路层负责，IP是网络层IP协议提供地址格式，是网络中每一个节点的逻辑地址，用以屏蔽硬件地址的差异。

### IP层如何知道报文该给哪个应用程序，如何区分TCP还是UDP报文
多路分解：IP数据报头部记录了协议标识，传输层报文头记录了目的端口号。

### https与http
https在http基础上加入了SSL/TLS协议，SSL/TLS依靠证书来验证服务器身份，并为浏览器和服务器之间提供加密通信。HTTPS访问服务器的流程：
- 用户向服务器发起安全连接请求
- 服务器返回经过CA（certificate authority）认证的数字证书，证书里包含了服务器的public key
- 用户拿到数字证书，用自己浏览器内置的CA证书解密得到服务器的public key
- 用户用服务器的public key加密接下来用于**对称加密**的密钥，传给服务器
- 服务器通过private key解密，获取对称加密的密钥，和用户进行接下来的加密通信

## 操作系统

### 用户态和内核态
- 仅在内核态下才能使用的指令称为**特权指令**，执行这些指令不经会影响运行程序自身，还会干扰其他程序以及操作系统。非特权指令在内核态和用户态下都能工作。
- 通过程序状态字（PSW）来将处理器的状态设置为内核或用户态
- 单一用户单一服务的操作系统不区分用户态和内核态，用户态和内核态是为了处理多用户多任务，通过硬件手段，限制某些代码，使其无法控制整个物理硬件，进而使不同用户，不同任务的代码无权修改整个物理硬件，进而保护操作系统的核心底层代码和其他用户的数据不被破坏或盗取。
- 内核态是操作系统管理程序执行时所处的状态，能够执行包含特权指令在内的一切指令，能够访问系统内所有的存储空间。
- 用户态是用户程序执行时处理器所处的状态，不能执行特权指令，只能访问用户地址空间。

### 用户态和内核态的切换

处理器从用户态切换到内核态的方法：**系统调用**、**异常**、**外部中断**
- 系统调用是操作系统的最小功能单位，是操作系统提供的用户接口，系统调用本身是一种**软中断**
- 异常，是由错误引起的如文件损坏、缺页故障等。
- 外部中断，通过两根信号线来通知处理器外设的状态变化，是**硬中断**

### 中断分类
- 外中断：来自处理器之外的中断信号，如时钟中断、键盘中断
- 内中断：来自处理器内部的中断信号，如硬件故障中断、程序性中断

### 并行和并发
并发强调的是一起出发，并行强调的是一起执行
与**并发**相对的是**顺序**：\
并发：无论上一个任务是否完成，当前任务都可以开始执行\
顺序：上一个开始执行的任务完成后，当前任务才能开始执行\
与**并行**相对应的是**串行**：\
串行：有一个任务执行单元从物理上只能一个任务接着一个任务的执行。\
并行：有多个任务执行单元从物理上可以多个任务一起执行。\
因此并行与并发并不是互斥概念，并发关注的是任务的抽象调度，并行关注的是任务的实际执行，它们又是相关的，比如并行一定允许并发。\
- 单核CPU多任务：并发（不用等上一个任务执行完才开始下一个任务）、串行（只有一个实际执行的CPU核）
- 多线程：并发、串行（所有线程都在同一个核上执行）；并发、并行（不同线程在不同核上执行）

### 为什么要并发？
如果是4个线程4个核心，则是并行，如果只有1个核心实际上4个线程也是串行执行的，但是设计程序的时候要**尽可能让程序能够并行**

### 系统调用
为了给应用程序的运行提供良好的环境，内核提供了一系列**具有特定功能的服务例程**，通过一组称为**系统调用**的接口提供给用户，系统调用把应用程序的请求传送至内核，调用相应的服务例程完成所需处理，将结果返回给应用程序。

### 进程和线程的区别
- 1、启动新的进程必须分配独立的地址空间，建立众多的数据表来维护它的代码段、堆栈段和数据段，系统**开销较大**，而线程之间使用相同的地址空间，共享大部分数据，切换的速度也比进程快，效率高，linux中线程和进程共用一个数据结构struct_task，所以linux中线程也就是lwp（轻量级进程），开一个进程和线程底层使用的都是clone函数，只是共享的数据不同，线程共享大部分数据。
- 2、由于进程间独立的特点，进程安全性比较高，也因为进程有独立的空间地址，一个进程崩溃后，在**保护模式**下不会对其他进程产生影响，而线程只是一个进程中的不同执行路径。一个线程死掉回收堆空间往往会导致连锁反应让整个进程死掉。
- 3、体系现在通信机制上，正因为进程间互不干扰，相互独立，进程的通信机制相对复杂，譬如管道、信号、消息队列、共享内存、套接字等通信机制，而线程由于共享数据段所以通信机制很方便。

### 进程和线程的选取
- 需要频繁**创建和销毁**优先使用线程，因为进程的创建和销毁代价很大。
- 因为对CPU系统的多核利用上线程更加占优，所以多机分布用进程，多核分布用线程
- 需要更稳定和安全时，用进程；需要速度时用线程。

### 线程崩溃不一定会导致进程崩溃
崩溃一般是由**共享地址空间带来的连锁反应**，比如一个线程堆栈溢出崩溃了，然后线程结束需要回收堆资源，导致其它共享地址空间的线程**使用相应数据**又发生了堆栈溢出。

### 线程间的共享和私有数据
#### 共享数据：
- 文件描述符表
- 每种信号的处理方式（SIG_IGN、SIG_DFL或自定义的信号处理函数）
- 当前工作目录
- 用户id和组id
- 地址空间
#### 私有数据：
- 线程id
- **上下文信息，包括各种寄存器的值、程序计数器和栈指针**
- **栈空间**（临时变量存储在栈空间中）
- errno变量
- 信号屏蔽字
- 调度优先级


### 系统调用的流程

### 如何检查内存泄漏

### 进程的状态转移

### malloc大内存跟物理内存的关系
### 虚拟内存

### 死锁成立的条件
- （1）互斥条件：一个资源只被一个进程占用
- （2）占有且等待：一个进程等待其他进程时，继续占有已分配的资源
- （3）不可抢占：不能强行抢占进程已占有的资源
- （4）循环等待：存在一个闭合的进程链，每个进程至少占有此链中下一个进程所需要的一个资源。
### 死锁检测和恢复
如果进程-资源分配图中没有环路，没有发生死锁 \
如果进程-资源分配图中有环路，可以分为两种情况：\
1、每种资源类中仅有一个资源，则系统发生了死锁，此时环路是系统发生死锁的充分必要条件，环路中进程是死锁进程。\
2、每种资源类中有多个资源，系统未必会发生死锁。\
**检测算法**：每种类型一个资源的死锁检测算法是通过检测有向图是否有环来实现，从一个节点出发进行深度优先搜索，对访问过的节点进行标记，如果访问过已经标记的节点，就表示有向图存在环，发生死锁\
**死锁恢复**：
  - 资源剥夺：剥夺陷于死锁的进程所占用的资源，但不撤销此进程直到接触死锁
  - 进程回退法：根据系统保存的检查点让所有进程回退，直到足以解除死锁，这种措施要求系统建立保存检查点、回退以及重启机制。
  - 进程撤销法：
    - 撤销陷入死锁的所有进程，解除死锁，继续运行
    - 逐个撤销陷入死锁的进程，回收其资源并重新分配，直至解除死锁。

### 死锁预防
- 互斥条件：不可避免
- 占有且等待：要求进城一次性请求所有需要的资源，并阻塞这个进程直到所有请求都满足。但是进程可能事先不知道它所需要的资源。
- 不可抢占：两种方式1、占有资源的进程去申请资源被拒绝时，必须释放最初占有的资源。2、任意两个进程优先级不同时，当一个进程请求另一个进程占用的资源时，操作系统可以**抢占**另一个，要求它释放资源
- 循环等待：定义资源类型的线性顺序来，若一个进程分配了R类型的资源，则接下来请求的只能是排在R类型之后的资源。但是会导致进程执行变慢。

### 死锁避免
死锁预防通过约束资源请求来至少破坏四个死锁条件中的一个，但会导致低效的资源使用和低效的进程执行。死锁避免**允许**三个必要条件（互斥、占有且等待、非抢占），但确保永远不会到达死锁点，**需要知道未来进程资源请求的情况**，两种避免方法：
- 若一个进程的请求会导致死锁，则不启动该进程
- 若一个进程增加的资源请求会导致死锁，则不允许这一资源分配

#### 资源拒绝分配（银行家算法）
**安全状态**指至少一个资源分配序列不会导致死锁（即所有进程都能运行直到结束），不安全状态指非安全的状态。顾客对应进程，钱对应资源，银行能贷出的钱有限，每个顾客都有一定的信用额（需要的总资源），顾客可以选择借一部分（申请部分资源），但不能保证顾客取得大量贷款后一定能偿还，银行家没有足够的本金时，拒绝贷款给顾客（拒绝资源）。

#### 死锁避免优缺点
- 优点：不需要死锁预防中的抢占和回滚进程，且比预防的限制少
- 缺点：也有许多限制：
  - 必须事先声明每个进程请求的最大资源
  - 进程的**执行顺序必须没有任何同步要求限制**
  - 分配资源的数量必须固定
  - 占有资源时进程不能退出

### 互斥锁、递归锁、读写锁、自旋锁、RCU
- 互斥锁：需要访问互斥资源时，尝试获取锁，获取失败则睡眠，资源使用完之后解锁，然后环形睡眠进程
- 递归锁：同一线程可以多次获取一个锁资源，而当所有次数都被释放，其他线程才能获取该锁资源。一般来说需要用到递归锁的情况说明设计是有问题的，尽量避免使用递归锁。
- 读写锁：读写锁有三种状态（读状态加锁，写状态加锁，未加锁）。读状态锁可以由多个进程占有，写状态锁只能由一个进程占有且当前没有进程占有读状态锁。
- 自旋锁：当一个线程尝试获取某一锁资源失败时，它不会睡眠，而是忙等待该锁被其他线程释放。好处是效率高，少了睡眠唤醒的开销，缺点是占用CPU资源。
- RCU：read-copy-update，**读数据时不需要加锁**，需要修改数据时，**先拷贝一份**，然后等到实际合适的时候通过回调机制将修改后的数据写回原处。可以支持**一个写操作**和多个读操作同时进行。

### 内存模型
地址空间由低到高：.text代码段、.data数据段、.bss段、堆区、内存映射区、栈区、内核空间。

### 页式管理、段式管理、段页式
基本概念：

## 数据结构
### 哈希表、哈希冲突如何解决？
**定义**：理想的散列表是一个数组，存储的每一个关键字通过散列函数映射到数组的不同位置，散列函数应该尽可能均匀分配关键字，并设计当两个关键字散列大到同一个值的时候如何处理。\
**哈希冲突**：哈希冲突就是不同的key产生了相同的地址，STL使用的是**开链法**，数组可以实现查找容易，但插入和删除难，链表查找难，插入和删除难，所以可以用二者组合起来，链表足够短还是够快的。\
**线性探测**：如果碰到冲突直接放在后一个位置，但是会形成主集团，即会在某个位置形成聚集，可以用二次探测来解决，即如果碰到冲突就放在后面+i平方的位置，但是会形成次主集团。


### 两个线程循环打印1-100