---
layout:     post
title:      "计网整理"
subtitle:   "浏览器中输入URL之后发生了什么"
date:       "2021-04-24"
author:     "Johann"
# # header-img: "img/post-bg-js-version.jpg"
tags:
    - 计网
---
- [浏览器中输入URL之后发生了什么？](#浏览器中输入url之后发生了什么)
  - [一、OSI分层](#一osi分层)
  - [二、传输层](#二传输层)
    - [1、TCP(Transmission Control Protocol, 传输控制协议)](#1tcptransmission-control-protocol-传输控制协议)
    - [2、UDP(User Datagram Protocol, 用户数据报协议)](#2udpuser-datagram-protocol-用户数据报协议)
    - [3、TCP三次握手和四次挥手](#3tcp三次握手和四次挥手)
  - [三、应用层](#三应用层)
    - [1、HTTP](#1http)
  - [三、浏览器输入URL之后发生了什么](#三浏览器输入url之后发生了什么)
# 浏览器中输入URL之后发生了什么？
## 一、OSI分层

| 名称 | 功能 | 协议 |
| :------ | :------ | :------ |
| **应用层** | 为应用程序提供服务 | 电子邮件协议SMTP、远程登录协议SSH、文件传输协议FTP、HTTP等 |
|表示层| 数据格式转化、数据加密|提供应用层数据的编码转换压缩加密等功能，确保一个应用层发送的数据能被另一个应用层的识别，HTML|
|会话层|建立、管理和维护会话|负责建立、管理和终止表示层实体之间的通信会话，SSL|
|**传输层**|建立、管理和维护端到端连接|管理两个节点间的数据传输，负责可靠传输、流量控制、差错控制，TCP、UDP|
|**网络层**|IP选址以及路由选择|通过IP寻址建立连个节点间的连接，选择合适的路由和交换节点，准确无误地将**数据包**按地址传给目的端，IP、IPv6|
|**数据链路层**|提供介质访问和链路管理|将比特组合成字节再组成帧，使用链路层地址实现互联设备间传送和识别**数据帧**，ARP、RARP|
|**物理层**|负责01与电压、光信号的转换|比特流与物理信号的转换，通过物理介质传输信息，Ethernet、IEEE802.2|

## 二、传输层
### 1、TCP(Transmission Control Protocol, 传输控制协议)
TCP是面向连接的，有流量控制，拥塞控制，提供全双工通信，面向字节流(把应用层传下来的报文看成是字节流，把字节流组织成为大小不等的数据块)，每一条TCP连接只能是一对一的。
### 2、UDP(User Datagram Protocol, 用户数据报协议)
UDP是无连接的，尽最大可能交付，没有拥塞控制，**面向报文**(对应用层的报文不拆分也不合并，只是添加UDP首部)，**支持一对一、一对多、多对一、多对多通信**  
TCP和UDP适用的场景：TCP适合金融等需要精确传输的场景、UDP适合对速度敏感的场景，如多人在线游戏、QQ、即时通信如视频通话、在线视频等。  

<table>
    <tr>
        <th>应用层协议</th><th>应用</th><th>传输层协议</th>
    </tr>
    <tr>
        <td>SMTP</td><td>电子邮件</td><td rowspan="4">TCP</td>
    </tr>
    <tr>
        <td>TELNET</td><td>远程终端接入</td>
    </tr>
    <tr>
        <td>HTTP</td><td>万维网</td>
    </tr>
      <tr>
        <td>FTP</td><td>文件传输</td>
    </tr>
    <tr>
        <td>DNS</td><td>域名转换</td><td rowspan="4">UDP</td>
    </tr>
    <tr>
        <td>TFTP</td><td>文件传输</td>
    </tr>
    <tr>
        <td>SNMP</td><td>网络管理</td>
    </tr>
      <tr>
        <td>NFS</td><td>远程文件服务器</td>
    </tr>
</table>


### 3、TCP三次握手和四次挥手
![avatar](/img/tcp-3handshack.jpg)
- **为什么一定要三次握手？**  
  第一次握手 : 客户端发送请求连接报文，SYN=1，ACK=0,初始序列号为Seq=x  
  第二次握手 : 服务器收到请求连接报文，向A发送连接确认报文，SYN=1，ACK=1,确认号ACKnum=x+1,初始序列号为Seq=y  
  第三次握手 : 客户端收到连接确认报文，向服务器发送确认，ACK=1,Seq=x+1,ACKnum=y+1
  
第一次握手，客户端发包，服务器收到了，服务器确认**客户端发送**以及**服务器接收**没问题，第二次握手，服务器发包客户端收到了，客户端确认**服务器收发没**以及**客户端收发**没问题，第三次握手客户端发包，服务器收到了，服务器确认**客户端接收，服务器发送**没问题，前两次握手服务器不能确定客户端的接收能力和自己的发送能力是否正常，**只能保证单向连接是畅通的**，而TCP是要求的双向通信，所以两次握手不行，为了实现可靠数据传输，**TCP协议的通信双方，都必须维护一个序列号Seq，以标识发送出去的数据包中，哪些是已经被对方收到的。三次握手的过程即是通信双方相互告知序列号起始值，并确认对方已经收到了序列号起始值的步骤**；如果只是两次握手，至多只有连接发起方的起始序列号能被确认，另一方选择的序列号则得不到确认。  
**第三次握手是为了防止已经失效的连接请求到达服务器，让服务器错误打开连接（如果只有两次握手的话）** 。假设只有两次握手，当网络延迟较高的时候，客户端发送一个连接请求，在但是服务器没有收到，此时客户端又发送了一个请求并正常完成数据传输并关闭了连接。之后，第一次发送的请求到达服务器，在只有两次握手的情况下，服务器会跟客户端建立连接，造成资源浪费和错误。如果是三次握手，服务器收不到客户端确认收到的报文（因为客户端已经关闭了）。
- **为什么是四次挥手**
![avatar](/img/tcp-4-handshack.jpg)
**由于是全双工通信，所以需要分别关闭，发送FIN和ACK一般会分开发，收到FIN仅表示对方不再发送了，但是还能接收，自己是不是要关闭数据通道要上层应用来决定，因此ACK和FIN会分开发。**  
第一次挥手：客户端发送FIN段，并包含一个希望接收者看到的自己当前序列号seq = x，同时包含一个ACK表示确认最近对面发过来的消息  
第二次挥手：服务器收到x并返回ACK=1,ACKnum=x+1，表示知道你不再发数据了，这时上层应用会被告知另一方发起了关闭，这将引起程序发起自己的关闭操作  
第三次挥手：服务器发送自己的FIN段，seq=y  
第四次挥手：客户端收到服务器发的FIN，进入TIME_WAIT状态，等待2*MSL之后释放连接  
**TIME_WAIT的作用**  
  time_wait发生在第四次挥手客户端收到服务器的FIN之后，作用有两个：一、**为了可靠的连接中断，保证客户端发送的最后一个ACK能到达服务器**，因为这个ACK可能会丢失，而服务器没有收到的话会再发一次FIN，客户端就能在2MSL这个时间内收到并给出回应，如果没有time_wait客户端直接关闭再收到FIN会产生RST导致异常。二、**为了保证旧的重复报文彻底消失**，为了防止已经失效的报文出现在这次连接中，客户端等待time_wait时间之后就可以让之前的报文全都消失。  

- **TCP粘包**   
  **发送端**要发送的数据小于TCP发送缓冲区大小，TCP将多次写入缓冲区的数据一次发出去，**接收端**应用层没有及时读取接收缓冲区中的数据  
  解决方案：消息定长，包尾加结束标志，比如\r\n
- **如果建立了连接，但是客户端发生故障怎么办**  
  TCP设有一个**保活计时器**，显然，客户端如果出现故障，服务器不能一直等下去，白白浪费资源。服务器每收到一次客户端的请求后都会重新复位这个计时器，时间通常是设置为2小时，若两小时还没有收到客户端的任何数据，服务器就会发送一个探测报文段，以后每隔75分钟发送一次。若一连发送10个探测报文仍然没反应，服务器就认为客户端出了故障，接着就关闭连接。
- **TCP滑动窗口**  
  发送方发送缓存中的数据可以分为四类：  
  1、已发送，已收到ACK；2、已发送，未收到ACK；3、未发送，但允许发送；4、未发送，不允许发送  
  发送窗口是：2、3  
  接收方接收缓存中的数据可以分为三类：  
  1、已接收；2、未接收，但准备接收；3、未接收，且不准备接收  
  接收窗口是：2  
  发送窗口大小取决于对方接收窗口，接收窗口取决于自己应用以及系统上的限制  
  发送窗口只有收到窗口内的ACK之后，才回左移窗口边界；接收窗口只有收到前面的字节的确认之后才会左移。前面还有字节未接收但收到了后面字节的情况下，窗口不会移动，确保重传。比如确认了500号但是收到了502号也不会移动，要等待501号的重传。
- **流量控制**  
  让发送端根据接收端的接收能力来发送数据，避免接收端高负荷下无法接收数据造成发送端一直重发，浪费资源。接收端会将自己缓冲区的大小放入TCP报头中发给发送端。
- **拥塞控制**  
  窗口控制导致发送端会同时发送大量数据，导致网络拥塞，因此通信开始时会通过**慢启动算法**来对数据量进行控制。TCP维护一个拥塞窗口cwnd(congestion window)，窗口大小取决于拥塞程度，并动态变化，linux内核默认使用Reno来进行拥塞控制
  ![avatar](/img/tcp-cwnd.jpg)
## 三、应用层
### 1、HTTP
**URL和URI** ：URI(Uniform Resource Identifier)统一资源标识符，为资源指定标识；URL(Uniform Resouce Location)统一资源定位符，标记一个资源并给出它的访问地址。  
**HTTP方法**
  

| 方法 | 简介 | 功能 |
| :------ | :------ | :------ |
| get | 用来请求访问指定资源，请求参数包含在请求头中 | 查询 |
| post | 向指定资源提交数据处理请求，数据包含在请求体中 | 新增 |
| put | 用文件取代指定内容 | 修改 |
| head | 类似于get但是不返回报文主体数据，用以确认URI有效性以及资源更新时间 |  |
| delete | 按请求URI删除指定资源 | 删除 |
| options | 查询支持的http方法 |  |
|trace|回显服务器收到的请求，用于测试和诊断||
|connect|用管道协议进行TCP连接(SSL/TLS)||
  

- **get和post的区别**
  get请求数据在URL中，对所有人可见，数据最大长度2kb，可以被缓存，post请求数据不会显示在URL中，数据长度无限制，请求结果不会被缓存。

**响应报文状态码**

| 1xx | 2xx | 3xx | 4xx | 5xx|
| :------ | :------ | :------ | :------ | :------ |
|信息性状态码，接收的请求正在处理|成功|重定向|客户端错误|服务器错误|

**详细状态码：**     

| 状态码 | 名称 | 简介 |
|---|---|---|
|100| Continue|客户端想向服务器发送实体，但不确定服务器能不能接受，所以首先会向服务器发送一个携带了100 continue的Except，服务器受到这个请求之后如果能接收客户端发来的实体，那就返回一个100 Continue响应，如果不能就返回一个错误码。|
|101|Switching Protocols|服务器正在根据客户端的指定，将协议切换成Update首部所列的协议。|
200 |OK|从客户端发来的请求在服务器端被正常处理了，实体的主体部分包含了所请求的资源|
|201 |Created|用于创建服务器对象的请求(比如：PUT)，响应的实体主体部分中应该包含各种引用了已经创建好的资源的URL，Location首部包含的则是具体的引用。|
|202| Accepted|请求已经被接收，但服务器还没有执行任何操作。并不意味着服务器会完成这个请求。|
|203| Non-Authoritative-Information|实体首部包含的信息不是来自于源端服务器，而是来自资源的一份副本。|
|204 |No Content|服务器成功处理了请求，但没有返回任何内容。主要用于在浏览器不转为显示新文档的情况下，对其进行更新(比如刷新表单页面)。|
|205 |Reset Content|用于浏览器的代码，告诉浏览器清除当前页面中所有HTML表单元素。|
|206| Partial Content|成功执行了一个部分或者Range请求，因为客户端可以通过一些特殊的首部来获取部分或者范围内的文档。响应报文中包含由 Content-Range 指定范围的实体内容。|
|300 |Multiple Choise|客户端请求一个实际指向多个资源的URL时会返回这个状态码，比如服务器上有某个HTML文档的英语和发育版本，返回这个状态码时会有一个选项列表，这样客户端就可以选择了。|
|301 |Moved Permanently|永久性重定向。该状态码表示请求的资源已被分配了新的 URI（该URL存在Location首部中），以后应使用资源现在所指的 URI。
|302| Found|临时性重定向。该状态码表示请求的资源已被分配了新的 URI（该URL存在Location首部中），希望用户（本次）能使用新的 URL 访问，将来的请求还应使用老的URL。注意：刚开始客户端发送POST请求，在收到302状态码后，使用GET请求访问新给的URL。在HTTP1.0生效。|
|303 |See Other|告知客户端应该用另一个URL（该URL存在Location首部中）来获取资源，其主要目的是允许POST请求的响应将客户端定向到某个资源上去。在HTTP1.1生效|
|304| Not Modified|此状态码适用于客户端发送了一个有条件的请求（ If-Match，If-ModifiedSince，If-None-Match，If-Range，If-Unmodified-Since ）。比如客户端想获取某个资源，并且是在XXX时间修改过的新的资源，如果这个资源没有修改，服务端就返回304给客户端|
|305| Use Proxy|用来告诉客户端必须通过一个代理来访问资源，代理的位置在Location里|
|306| |还没用这个状态码|
|307| Temporary Redirect|临时重定向。该状态码与 302 Found 有着相同的含义。307 会遵照浏览器标准，不会从 POST 变成 GET|
|400| Bad Request|该状态码表示请求报文中存在语法错误。|
|401| Unauthorized|告诉客户端，要想获取资源的访问权，首先要对自己认证|
|402 |Payment Required|此状态码还未被使用，保留中|
|403 |Forbidden|表明服务器拒绝了这个来自客户端的请求。一般不会说明缘由|
|404 |Not Found|表明服务器上无法找到请求的资源。一般还会包含一个实体（比如404页面），以便客户端给用户看。|
|405| Method Not Allowed|客户端发起的请求中带有所有请求的URL不支持的方法。同时应该在响应中包含Allow首部，以告诉客户端可以使用什么方法|
|406 |Not Accepted|客户端可以在请求首部中指明自己愿意接收什么类型的实体，但是当服务器没有这种类型实体的时候，会发送406.407 proxy Authentication Required：与401类似，但是用于要求对资源进行认证的代理服务器|
|408| Request TImeout|如果客户端完成请求所话的时间太长，服务器返回此代码并关闭连接|
|409| Conflict|用于说明请求可能在资源上引发一些冲突。服务器担心请求会引发冲突时，发送此代码。并在响应的主体中描述冲突|
|410 |Gone|与404类似，只是服务器曾经拥有过此资源|
|411 |Length Required|服务器要求客户端发请求的时候包含Content-Length首部的时候发送此代码|
|412|Precondition Failed|客户端发起了条件请求，且其中一个条件失败了的时候会收到此状态码|
|413| Request Entity Too large|客户端发送的实体主体比服务器所能希望处理的要大时，使用此代码|
|414 |Request URL Too Long|客户端发送的请求URL比服务器所能希望处理的要长时，使用此代码|
|415 |Unsupported Media Type|服务器无法理解或无法支持客户端所发实体内容类型时，使用此状态码|
|416 |Request Range Not Satisfiable|请求报文所请求的是指定资源的某个范围，而此范围无效或者无法满足时，使用此状态码|
|417 |Expectation Failed|请求的Expect请求首部包含了一个期望，但是服务器无法满足此期望时，使用此状态码|
  

## 三、浏览器输入URL之后发生了什么

**URL(Uniform Resource Locator, 统一资源定位符)**：用于定位互联网上资源，俗称“网址”。一个典型的URL例子：

```css
schmeme://host.domain:port/path/filename
```
各个部分定义如下：

- schmeme : 因特网服务类型。比如http、https、ftp、file、
- host : 域主机(http的默认主机是www)
- domain : 因特网域名如 zju.edu.cn
- port : 主机上端口号(http默认端口号80)
- path : 服务器上的路径(如果省略，则文档必须位于根目录中)
- filename : 资源名称

![avatar](/img/a-url.jpg)

- 1、DNS域名解析
浏览器不能直接通过域名查找服务器，而是要通过IP，IP是32位二进制数，而域名是英文字母配合数字，域名更适合人类记忆，IP更适合计算机，因此需要DNS域名解析服务。  
**解析流程：**  
  - 浏览器缓存 : 浏览器按照一定频率缓存DNS记录
  - 操作系统缓存 : host文件中
  - 路由缓存
  - ISP的DNS服务器 : 运营商会提供DNS查询请求
根DNS服务器 : 递归查询，比如会先问根服务器.cn的域名服务器的IP，然后再问.edu的域名服务器的IP

- 2、TCP连接
根据IP和端口号与服务器建立连接(三次握手)
- 3、发送HTTP请求
客户端发送HTTP请求，浏览器发送只能使用GET和POST方法，打开网页使用的是GET方法。在请求行中包含请求方法、请求资源路径，附带自身的认证和身份信息，发给服务器
- 4、服务器处理请求并返回HTTP报文
服务器将响应报文返回给客户端，浏览器拿到响应文本html之后进行渲染
- 5、数据传输完毕，断开TCP连接(四次挥手)

