---
layout:     post
title:      "计网整理"
subtitle:   "浏览器中输入URL之后发生了什么"
date:       "2021-04-24"
author:     "Johann"
# # header-img: "img/post-bg-js-version.jpg"
tags:
    - 计网
---

# 浏览器中输入URL之后发生了什么？
## 一、OSI分层

| 名称 | 功能 | 协议 |
| :------ | :------ | :------ |
| **应用层** | 为应用程序提供服务 | 电子邮件协议SMTP、远程登录协议SSH、文件传输协议FTP、HTTP等 |
|表示层| 数据格式转化、数据加密|提供应用层数据的编码转换压缩加密等功能，确保一个应用层发送的数据能被另一个应用层的识别，HTML|
|会话层|建立、管理和维护会话|负责建立、管理和终止表示层实体之间的通信会话，SSL|
|**传输层**|建立、管理和维护端到端连接|管理两个节点间的数据传输，负责可靠传输、流量控制、差错控制，TCP、UDP|
|**网络层**|IP选址以及路由选择|通过IP寻址建立连个节点间的连接，选择合适的路由和交换节点，准确无误地将**数据包**按地址传给目的端，IP、IPv6|
|**数据链路层**|提供介质访问和链路管理|将比特组合成字节再组成帧，使用链路层地址实现互联设备间传送和识别**数据帧**，ARP、RARP|
|**物理层**|负责01与电压、光信号的转换|比特流与物理信号的转换，通过物理介质传输信息，Ethernet、IEEE802.2|

## 二、传输层
### 1、TCP(Transmission Control Protocol, 传输控制协议)
TCP是面向连接的，有流量控制，拥塞控制，提供全双工通信，面向字节流(把应用层传下来的报文看成是字节流，把字节流组织成为大小不等的数据块)，每一条TCP连接只能是一对一的。
### 2、UDP(User Datagram Protocol, 用户数据报协议)
UDP是无连接的，尽最大可能交付，没有拥塞控制，面向报文(对应用层的报文不拆分也不合并，只是添加UDP首部)，支持一对一、一对多、多对一、多对多通信
### 3、TCP三次握手和四次挥手
![avatar](/img/tcp-3handshack.jpg)
- **为什么一定要三次握手？**  
  第一次握手 : 客户端发送请求连接报文，SYN=1，ACK=0,初始序列号为Seq=x  
  第二次握手 : 服务器收到请求连接报文，向A发送连接确认报文，SYN=1，ACK=1,确认号ACKnum=x+1,初始序列号为Seq=y  
  第三次握手 : 客户端收到连接确认报文，向服务器发送确认，ACK=1,Seq=x+1,ACKnum=y+1
  
第一次握手，客户端发包，服务器收到了，服务器确认**客户端发送**以及**服务器接收**没问题，第二次握手，服务器发包客户端收到了，客户端确认**服务器收发没**以及**客户端收发**没问题，第三次握手客户端发包，服务器收到了，服务器确认**客户端接收，服务器发送**没问题，前两次握手服务器不能确定客户端的接收能力和自己的发送能力是否正常，**只能保证单向连接是畅通的**，而TCP是要求的双向通信，所以两次握手不行，为了实现可靠数据传输，**TCP协议的通信双方，都必须维护一个序列号Seq，以标识发送出去的数据包中，哪些是已经被对方收到的。三次握手的过程即是通信双方相互告知序列号起始值，并确认对方已经收到了序列号起始值的步骤**；如果只是两次握手，至多只有连接发起方的起始序列号能被确认，另一方选择的序列号则得不到确认。  
**第三次握手是为了防止已经失效的连接请求到达服务器，让服务器错误打开连接（如果只有两次握手的话）** 。假设只有两次握手，当网络延迟较高的时候，客户端发送一个连接请求，在但是服务器没有收到，此时客户端又发送了一个请求并正常完成数据传输并关闭了连接。之后，第一次发送的请求到达服务器，在只有两次握手的情况下，服务器会跟客户端建立连接，造成资源浪费和错误。如果是三次握手，服务器收不到客户端确认收到的报文（因为客户端已经关闭了）。
- **为什么是四次挥手**
![avatar](/img/tcp-4-handshack.jpg)
**由于是全双工通信，所以需要分别关闭，发送FIN和ACK一般会分开发，收到FIN仅表示对方不再发送了，但是还能接收，自己是不是要关闭数据通道要上层应用来决定，因此ACK和FIN会分开发。**  

第一次挥手：客户端发送FIN段，并包含一个希望接收者看到的自己当前序列号seq = x，同时包含一个ACK表示确认最近对面发过来的消息  
第二次挥手：服务器收到x并返回ACK=1,ACKnum=x+1，表示知道你不再发数据了，这时上层应用会被告知另一方发起了关闭，这将引起程序发起自己的关闭操作  
第三次挥手：服务器发送自己的FIN段，seq=y  
第四次挥手：客户端收到服务器发的FIN，进入TIME_WAIT状态，等待2*MSL之后释放连接  
**TIME_WAIT的作用**  
  time_wait发生在第四次挥手客户端收到服务器的FIN之后，作用有两个：一、**为了可靠的连接中断，保证客户端发送的最后一个ACK能到达服务器**，因为这个ACK可能会丢失，而服务器没有收到的话会再发一次FIN，客户端就能在2MSL这个时间内收到并给出回应，如果没有time_wait客户端直接关闭再收到FIN会产生RST导致异常。二、**为了保证旧的重复报文彻底消失**，为了防止已经失效的报文出现在这次连接中，客户端等待time_wait时间之后就可以让之前的报文全都消失。  

- TCP粘包  
  **发送端**要发送的数据小于TCP发送缓冲区大小，TCP将多次写入缓冲区的数据一次发出去，**接收端**应用层没有及时读取接收缓冲区中的数据  
  解决方案：消息定长，包尾加结束标志，比如\r\n
## 三、应用层
### 1、HTTP
**URL和URI** ：URI(Uniform Resource Identifier)统一资源标识符，为资源指定标识；URL(Uniform Resouce Location)统一资源定位符，标记一个资源并给出它的访问地址。  
**HTTP方法**
| 方法 | 简介 | 功能 |
| :------ | :------ | :------ |
| get | 用来请求访问指定资源，请求参数包含在请求头中 | 查询 |
| post | 向指定资源提交数据处理请求，数据包含在请求体中 | 新增 |
| put | 用文件取代指定内容 | 修改 |
| head | 类似于get但是不返回报文主体数据，用以确认URI有效性以及资源更新时间 |  |
| delete | 按请求URI删除指定资源 | 删除 |
| options | 查询支持的http方法 |  |
|trace|回显服务器收到的请求，用于测试和诊断|
|connect|用管道协议进行TCP连接(SSL/TLS)|

**响应报文状态码**
| 1xx | 2xx | 3xx | 4xx | 5xx|
| :------ | :------ | :------ | :------ | :------ |
|信息性状态码，接收的请求正在处理|成功|重定向|客户端错误|服务器错误|

## 三、浏览器输入URL之后发生了什么

**URL(Uniform Resource Locator, 统一资源定位符)**：用于定位互联网上资源，俗称“网址”。一个典型的URL例子：

```css
schmeme://host.domain:port/path/filename
```
各个部分定义如下：

- schmeme : 因特网服务类型。比如http、https、ftp、file、
- host : 域主机(http的默认主机是www)
- domain : 因特网域名如 zju.edu.cn
- port : 主机上端口号(http默认端口号80)
- path : 服务器上的路径(如果省略，则文档必须位于根目录中)
- filename : 资源名称

![avatar](/img/a-url.jpg)

### 1、DNS域名解析
浏览器不能直接通过域名查找服务器，而是要通过IP，IP是32位二进制数，而域名是英文字母配合数字，域名更适合人类记忆，IP更适合计算机，因此需要DNS域名解析服务。  
**解析流程：**  
- 浏览器缓存 : 浏览器按照一定频率缓存DNS记录
- 操作系统缓存 : host文件中
- 路由缓存
- ISP的DNS服务器 : 运营商会提供DNS查询请求
- 根DNS服务器 : 递归查询，比如会先问根服务器.cn的域名服务器的IP，然后再问.edu的域名服务器的IP

### 2、TCP连接
根据IP和端口号与服务器建立连接(三次握手)
### 3、发送HTTP请求
客户端发送HTTP请求，浏览器发送只能使用GET和POST方法，打开网页使用的是GET方法。在请求行中包含请求方法、请求资源路径，附带自身的认证和身份信息，发给服务器
### 4、服务器处理请求并返回HTTP报文
服务器将响应报文返回给客户端，浏览器拿到响应文本html之后进行渲染
### 5、数据传输完毕，断开TCP连接(四次挥手)

