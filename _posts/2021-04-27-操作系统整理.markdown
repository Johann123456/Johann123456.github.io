---
layout:     post
title:      "操作系统"
subtitle:   "整理中…"
date:       "2021-04-27"
author:     "Johann"
# # header-img: "img/post-bg-js-version.jpg"
tags:
    - 操作系统
---
- [进程和线程](#进程和线程)
  - [进程](#进程)
    - [进程间通信](#进程间通信)
  - [线程](#线程)
  - [进程和线程的区别](#进程和线程的区别)
- [内存管理](#内存管理)
  - [虚拟内存](#虚拟内存)
  - [分段](#分段)
  - [分页](#分页)
  - [段页式内存管理](#段页式内存管理)
  - [linux内存管理](#linux内存管理)
# 进程和线程
## 进程
### 进程间通信
每个进程的用户地址空间都是独立的，一般不能互相访问，但内核和空间是每个进程都共享的，所以进程间通信必须通过内核。进程间通信共有6种方式：管道、消息队列、共享内存、信号量、信号、Socket
- 管道
  
  ![avatar](/img/pipe.jpg)
  内核当中的一串缓存，分为匿名管道和命名管道，匿名管道只能在存在父子关系的进程间通信，比如`ps auxf | grep mysql`就是一个匿名管道，**通信是单向的，数据是无格式的数据流**，两个进程ps和grep都是shell的子进程。命名管道`FIFO`可以在任意两个进程间创建管道，但是效率很低，不适合频繁交换数据。
- 消息队列
  
  消息队列是内核中的消息链表，**生命周期随内核**，如果没有释消息放队列或者没关闭操作系统，消息队列一直存在，而匿名管道生命周期是随着进程创建而创建随着进程结束而销毁。特点是**通信不及时**，**大小有限制**，在系统中会有定义最大的队列长度，**同时存在用户态和内核态之间的数据拷贝的开销**，进程写数据到内核中的消息队列时会发生数据由用户态拷贝到内核态的过程，同理，另一进程读取的时候也会发生拷贝。
- 共享内存
  
  **为了避免消息队列的读取和写入的拷贝过程**，共享内存。拿出一块虚拟地址空间，映射到相同的物理内存中，两个进程共享这块内存，一个进程写入另一个进程马上就能看到。
- 信号量
  
  共享内存会有新的问题：**如果多个进程同时修改同一个共享内存，很有可能发生冲突**，为了防止多进程竞争共享资源，需要一个保护机制，使得任何时刻共享资源只能被一个进程访问，这个机制就是**信号量**，控制信号量的方式有两种原子操作：
  - 一个是 P 操作，这个操作会把信号量减去 -1，相减后如果信号量 < 0，则表明资源已被占用，进程需阻塞等待；相减后如果信号量 >= 0，则表明还有资源可使用，进程可正常继续执行。
  - 另一个是 V 操作，这个操作会把信号量加上 1，相加后如果信号量 <= 0，则表明当前有阻塞中的进程，于是会将该进程唤醒运行；相加后如果信号量 > 0，则表明当前没有阻塞中的进程。
    
    **两个进程互斥，则初始化信号量为1，**
    ![/avatar](/img/ABhuchi.jpg)
      
      **两个进程同步，则初始化信号量为0**
    ![/avatar](/img/ABsyn.jpg)
    B一定要等A执行完了才能执行，如果B先执行，执行到P操作信号量 < 0, B阻塞等待。A执行完之后，执行了V操作，信号量变为0，阻塞在P操作的进程B被唤醒，继续执行，此时B可以读取A产生的数据了。
- 信号
  
  上面几种都是正常状态下的通信，**异常状态**下就要用信号来通知进程，信号是进程间通信机制中唯一的异步通信机制，可以在任何时候发送信号给一个进程，一旦有信号产生，就有三种进程对信号的处理方式：1、执行默认操作；2、捕捉信号(catch?)；3、忽略信号。
- Socket
  
  上述的通信方式都是在同一台主机上进行的，如果要跨网络在不同主机上通信就要用Socket了。
## 线程
## 进程和线程的区别
# 内存管理
## 虚拟内存
## 分段
## 分页
## 段页式内存管理
## linux内存管理